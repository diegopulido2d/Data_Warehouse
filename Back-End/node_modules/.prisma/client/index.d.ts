
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model channels
 */

export type channels = {
  id: number
  name: string
}

/**
 * Model cities
 */

export type cities = {
  id: number
  name: string
  countries_id: number
  isactive: boolean | null
}

/**
 * Model companies
 */

export type companies = {
  id: number
  name: string
  address: string
  email: string
  phone: string
  cities_id: number
  isactive: boolean | null
}

/**
 * Model contacts
 */

export type contacts = {
  id: number
  username: string
  lastname: string
  email: string
  job_tittle: string
  create_time: Date | null
  address: string | null
  interest: number | null
  imgUrl: string | null
  users_id: number
  companies_id: number
  cities_id: number
  isactive: boolean | null
}

/**
 * Model contacts_channels
 */

export type contacts_channels = {
  id: number
  acount: string
  channels_id: number
  preferences_id: number
  contacts_id: number
}

/**
 * Model countries
 */

export type countries = {
  id: number
  name: string
  regions_id: number
  isactive: boolean | null
}

/**
 * Model preferences
 */

export type preferences = {
  id: number
  name: string
}

/**
 * Model regions
 */

export type regions = {
  id: number
  name: string
  isactive: boolean | null
}

/**
 * Model users
 */

export type users = {
  id: number
  username: string
  lastname: string
  email: string
  password: string
  create_time: Date | null
  isadmin: boolean | null
  isactive: boolean | null
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Channels
 * const channels = await prisma.channels.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Channels
   * const channels = await prisma.channels.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;


      /**
   * `prisma.channels`: Exposes CRUD operations for the **channels** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Channels
    * const channels = await prisma.channels.findMany()
    * ```
    */
  get channels(): Prisma.channelsDelegate<GlobalReject>;

  /**
   * `prisma.cities`: Exposes CRUD operations for the **cities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.cities.findMany()
    * ```
    */
  get cities(): Prisma.citiesDelegate<GlobalReject>;

  /**
   * `prisma.companies`: Exposes CRUD operations for the **companies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.companies.findMany()
    * ```
    */
  get companies(): Prisma.companiesDelegate<GlobalReject>;

  /**
   * `prisma.contacts`: Exposes CRUD operations for the **contacts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contacts.findMany()
    * ```
    */
  get contacts(): Prisma.contactsDelegate<GlobalReject>;

  /**
   * `prisma.contacts_channels`: Exposes CRUD operations for the **contacts_channels** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts_channels
    * const contacts_channels = await prisma.contacts_channels.findMany()
    * ```
    */
  get contacts_channels(): Prisma.contacts_channelsDelegate<GlobalReject>;

  /**
   * `prisma.countries`: Exposes CRUD operations for the **countries** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.countries.findMany()
    * ```
    */
  get countries(): Prisma.countriesDelegate<GlobalReject>;

  /**
   * `prisma.preferences`: Exposes CRUD operations for the **preferences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Preferences
    * const preferences = await prisma.preferences.findMany()
    * ```
    */
  get preferences(): Prisma.preferencesDelegate<GlobalReject>;

  /**
   * `prisma.regions`: Exposes CRUD operations for the **regions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Regions
    * const regions = await prisma.regions.findMany()
    * ```
    */
  get regions(): Prisma.regionsDelegate<GlobalReject>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 3.1.1
   * Query Engine version: c22652b7e418506fab23052d569b85d3aec4883f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Same as JsonObject, but allows undefined
   */
  export type InputJsonObject = {[Key in string]?: JsonValue}
 
  export interface InputJsonArray extends Array<JsonValue> {}
 
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: 'DbNull'

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: 'JsonNull'

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: 'AnyNull'

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    channels: 'channels',
    cities: 'cities',
    companies: 'companies',
    contacts: 'contacts',
    contacts_channels: 'contacts_channels',
    countries: 'countries',
    preferences: 'preferences',
    regions: 'regions',
    users: 'users'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ChannelsCountOutputType
   */


  export type ChannelsCountOutputType = {
    contacts_channels: number
  }

  export type ChannelsCountOutputTypeSelect = {
    contacts_channels?: boolean
  }

  export type ChannelsCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ChannelsCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ChannelsCountOutputType
    : S extends undefined
    ? never
    : S extends ChannelsCountOutputTypeArgs
    ?'include' extends U
    ? ChannelsCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ChannelsCountOutputType ?ChannelsCountOutputType [P]
  : 
     never
  } 
    : ChannelsCountOutputType
  : ChannelsCountOutputType




  // Custom InputTypes

  /**
   * ChannelsCountOutputType without action
   */
  export type ChannelsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ChannelsCountOutputType
     * 
    **/
    select?: ChannelsCountOutputTypeSelect | null
  }



  /**
   * Count Type CitiesCountOutputType
   */


  export type CitiesCountOutputType = {
    companies: number
    contacts: number
  }

  export type CitiesCountOutputTypeSelect = {
    companies?: boolean
    contacts?: boolean
  }

  export type CitiesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CitiesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CitiesCountOutputType
    : S extends undefined
    ? never
    : S extends CitiesCountOutputTypeArgs
    ?'include' extends U
    ? CitiesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CitiesCountOutputType ?CitiesCountOutputType [P]
  : 
     never
  } 
    : CitiesCountOutputType
  : CitiesCountOutputType




  // Custom InputTypes

  /**
   * CitiesCountOutputType without action
   */
  export type CitiesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CitiesCountOutputType
     * 
    **/
    select?: CitiesCountOutputTypeSelect | null
  }



  /**
   * Count Type CompaniesCountOutputType
   */


  export type CompaniesCountOutputType = {
    contacts: number
  }

  export type CompaniesCountOutputTypeSelect = {
    contacts?: boolean
  }

  export type CompaniesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CompaniesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CompaniesCountOutputType
    : S extends undefined
    ? never
    : S extends CompaniesCountOutputTypeArgs
    ?'include' extends U
    ? CompaniesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CompaniesCountOutputType ?CompaniesCountOutputType [P]
  : 
     never
  } 
    : CompaniesCountOutputType
  : CompaniesCountOutputType




  // Custom InputTypes

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CompaniesCountOutputType
     * 
    **/
    select?: CompaniesCountOutputTypeSelect | null
  }



  /**
   * Count Type ContactsCountOutputType
   */


  export type ContactsCountOutputType = {
    contacts_channels: number
  }

  export type ContactsCountOutputTypeSelect = {
    contacts_channels?: boolean
  }

  export type ContactsCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ContactsCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ContactsCountOutputType
    : S extends undefined
    ? never
    : S extends ContactsCountOutputTypeArgs
    ?'include' extends U
    ? ContactsCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ContactsCountOutputType ?ContactsCountOutputType [P]
  : 
     never
  } 
    : ContactsCountOutputType
  : ContactsCountOutputType




  // Custom InputTypes

  /**
   * ContactsCountOutputType without action
   */
  export type ContactsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ContactsCountOutputType
     * 
    **/
    select?: ContactsCountOutputTypeSelect | null
  }



  /**
   * Count Type CountriesCountOutputType
   */


  export type CountriesCountOutputType = {
    cities: number
  }

  export type CountriesCountOutputTypeSelect = {
    cities?: boolean
  }

  export type CountriesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CountriesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CountriesCountOutputType
    : S extends undefined
    ? never
    : S extends CountriesCountOutputTypeArgs
    ?'include' extends U
    ? CountriesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CountriesCountOutputType ?CountriesCountOutputType [P]
  : 
     never
  } 
    : CountriesCountOutputType
  : CountriesCountOutputType




  // Custom InputTypes

  /**
   * CountriesCountOutputType without action
   */
  export type CountriesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CountriesCountOutputType
     * 
    **/
    select?: CountriesCountOutputTypeSelect | null
  }



  /**
   * Count Type PreferencesCountOutputType
   */


  export type PreferencesCountOutputType = {
    contacts_channels: number
  }

  export type PreferencesCountOutputTypeSelect = {
    contacts_channels?: boolean
  }

  export type PreferencesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PreferencesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PreferencesCountOutputType
    : S extends undefined
    ? never
    : S extends PreferencesCountOutputTypeArgs
    ?'include' extends U
    ? PreferencesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof PreferencesCountOutputType ?PreferencesCountOutputType [P]
  : 
     never
  } 
    : PreferencesCountOutputType
  : PreferencesCountOutputType




  // Custom InputTypes

  /**
   * PreferencesCountOutputType without action
   */
  export type PreferencesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PreferencesCountOutputType
     * 
    **/
    select?: PreferencesCountOutputTypeSelect | null
  }



  /**
   * Count Type RegionsCountOutputType
   */


  export type RegionsCountOutputType = {
    countries: number
  }

  export type RegionsCountOutputTypeSelect = {
    countries?: boolean
  }

  export type RegionsCountOutputTypeGetPayload<
    S extends boolean | null | undefined | RegionsCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? RegionsCountOutputType
    : S extends undefined
    ? never
    : S extends RegionsCountOutputTypeArgs
    ?'include' extends U
    ? RegionsCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof RegionsCountOutputType ?RegionsCountOutputType [P]
  : 
     never
  } 
    : RegionsCountOutputType
  : RegionsCountOutputType




  // Custom InputTypes

  /**
   * RegionsCountOutputType without action
   */
  export type RegionsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RegionsCountOutputType
     * 
    **/
    select?: RegionsCountOutputTypeSelect | null
  }



  /**
   * Count Type UsersCountOutputType
   */


  export type UsersCountOutputType = {
    contacts: number
  }

  export type UsersCountOutputTypeSelect = {
    contacts?: boolean
  }

  export type UsersCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UsersCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UsersCountOutputType
    : S extends undefined
    ? never
    : S extends UsersCountOutputTypeArgs
    ?'include' extends U
    ? UsersCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UsersCountOutputType ?UsersCountOutputType [P]
  : 
     never
  } 
    : UsersCountOutputType
  : UsersCountOutputType




  // Custom InputTypes

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     * 
    **/
    select?: UsersCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model channels
   */


  export type AggregateChannels = {
    _count: ChannelsCountAggregateOutputType | null
    _avg: ChannelsAvgAggregateOutputType | null
    _sum: ChannelsSumAggregateOutputType | null
    _min: ChannelsMinAggregateOutputType | null
    _max: ChannelsMaxAggregateOutputType | null
  }

  export type ChannelsAvgAggregateOutputType = {
    id: number | null
  }

  export type ChannelsSumAggregateOutputType = {
    id: number | null
  }

  export type ChannelsMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type ChannelsMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type ChannelsCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type ChannelsAvgAggregateInputType = {
    id?: true
  }

  export type ChannelsSumAggregateInputType = {
    id?: true
  }

  export type ChannelsMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type ChannelsMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type ChannelsCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type ChannelsAggregateArgs = {
    /**
     * Filter which channels to aggregate.
     * 
    **/
    where?: channelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of channels to fetch.
     * 
    **/
    orderBy?: Enumerable<channelsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: channelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` channels from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` channels.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned channels
    **/
    _count?: true | ChannelsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChannelsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChannelsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChannelsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChannelsMaxAggregateInputType
  }

  export type GetChannelsAggregateType<T extends ChannelsAggregateArgs> = {
        [P in keyof T & keyof AggregateChannels]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChannels[P]>
      : GetScalarType<T[P], AggregateChannels[P]>
  }


    
    
  export type ChannelsGroupByArgs = {
    where?: channelsWhereInput
    orderBy?: Enumerable<channelsOrderByWithAggregationInput>
    by: Array<ChannelsScalarFieldEnum>
    having?: channelsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChannelsCountAggregateInputType | true
    _avg?: ChannelsAvgAggregateInputType
    _sum?: ChannelsSumAggregateInputType
    _min?: ChannelsMinAggregateInputType
    _max?: ChannelsMaxAggregateInputType
  }


  export type ChannelsGroupByOutputType = {
    id: number
    name: string
    _count: ChannelsCountAggregateOutputType | null
    _avg: ChannelsAvgAggregateOutputType | null
    _sum: ChannelsSumAggregateOutputType | null
    _min: ChannelsMinAggregateOutputType | null
    _max: ChannelsMaxAggregateOutputType | null
  }

  type GetChannelsGroupByPayload<T extends ChannelsGroupByArgs> = Promise<
    Array<
      PickArray<ChannelsGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof ChannelsGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], ChannelsGroupByOutputType[P]> 
            : GetScalarType<T[P], ChannelsGroupByOutputType[P]>
        }
      > 
    >


  export type channelsSelect = {
    id?: boolean
    name?: boolean
    contacts_channels?: boolean | contacts_channelsFindManyArgs
    _count?: boolean | ChannelsCountOutputTypeArgs
  }

  export type channelsInclude = {
    contacts_channels?: boolean | contacts_channelsFindManyArgs
    _count?: boolean | ChannelsCountOutputTypeArgs
  }

  export type channelsGetPayload<
    S extends boolean | null | undefined | channelsArgs,
    U = keyof S
      > = S extends true
        ? channels
    : S extends undefined
    ? never
    : S extends channelsArgs | channelsFindManyArgs
    ?'include' extends U
    ? channels  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'contacts_channels'
        ? Array < contacts_channelsGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? ChannelsCountOutputTypeGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof channels ?channels [P]
  : 
          P extends 'contacts_channels'
        ? Array < contacts_channelsGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? ChannelsCountOutputTypeGetPayload<S['select'][P]> | null : never
  } 
    : channels
  : channels


  type channelsCountArgs = Merge<
    Omit<channelsFindManyArgs, 'select' | 'include'> & {
      select?: ChannelsCountAggregateInputType | true
    }
  >

  export interface channelsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Channels that matches the filter.
     * @param {channelsFindUniqueArgs} args - Arguments to find a Channels
     * @example
     * // Get one Channels
     * const channels = await prisma.channels.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends channelsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, channelsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'channels'> extends True ? CheckSelect<T, Prisma__channelsClient<channels>, Prisma__channelsClient<channelsGetPayload<T>>> : CheckSelect<T, Prisma__channelsClient<channels | null >, Prisma__channelsClient<channelsGetPayload<T> | null >>

    /**
     * Find the first Channels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {channelsFindFirstArgs} args - Arguments to find a Channels
     * @example
     * // Get one Channels
     * const channels = await prisma.channels.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends channelsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, channelsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'channels'> extends True ? CheckSelect<T, Prisma__channelsClient<channels>, Prisma__channelsClient<channelsGetPayload<T>>> : CheckSelect<T, Prisma__channelsClient<channels | null >, Prisma__channelsClient<channelsGetPayload<T> | null >>

    /**
     * Find zero or more Channels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {channelsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Channels
     * const channels = await prisma.channels.findMany()
     * 
     * // Get first 10 Channels
     * const channels = await prisma.channels.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const channelsWithIdOnly = await prisma.channels.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends channelsFindManyArgs>(
      args?: SelectSubset<T, channelsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<channels>>, PrismaPromise<Array<channelsGetPayload<T>>>>

    /**
     * Create a Channels.
     * @param {channelsCreateArgs} args - Arguments to create a Channels.
     * @example
     * // Create one Channels
     * const Channels = await prisma.channels.create({
     *   data: {
     *     // ... data to create a Channels
     *   }
     * })
     * 
    **/
    create<T extends channelsCreateArgs>(
      args: SelectSubset<T, channelsCreateArgs>
    ): CheckSelect<T, Prisma__channelsClient<channels>, Prisma__channelsClient<channelsGetPayload<T>>>

    /**
     * Create many Channels.
     *     @param {channelsCreateManyArgs} args - Arguments to create many Channels.
     *     @example
     *     // Create many Channels
     *     const channels = await prisma.channels.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends channelsCreateManyArgs>(
      args?: SelectSubset<T, channelsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Channels.
     * @param {channelsDeleteArgs} args - Arguments to delete one Channels.
     * @example
     * // Delete one Channels
     * const Channels = await prisma.channels.delete({
     *   where: {
     *     // ... filter to delete one Channels
     *   }
     * })
     * 
    **/
    delete<T extends channelsDeleteArgs>(
      args: SelectSubset<T, channelsDeleteArgs>
    ): CheckSelect<T, Prisma__channelsClient<channels>, Prisma__channelsClient<channelsGetPayload<T>>>

    /**
     * Update one Channels.
     * @param {channelsUpdateArgs} args - Arguments to update one Channels.
     * @example
     * // Update one Channels
     * const channels = await prisma.channels.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends channelsUpdateArgs>(
      args: SelectSubset<T, channelsUpdateArgs>
    ): CheckSelect<T, Prisma__channelsClient<channels>, Prisma__channelsClient<channelsGetPayload<T>>>

    /**
     * Delete zero or more Channels.
     * @param {channelsDeleteManyArgs} args - Arguments to filter Channels to delete.
     * @example
     * // Delete a few Channels
     * const { count } = await prisma.channels.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends channelsDeleteManyArgs>(
      args?: SelectSubset<T, channelsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {channelsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Channels
     * const channels = await prisma.channels.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends channelsUpdateManyArgs>(
      args: SelectSubset<T, channelsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Channels.
     * @param {channelsUpsertArgs} args - Arguments to update or create a Channels.
     * @example
     * // Update or create a Channels
     * const channels = await prisma.channels.upsert({
     *   create: {
     *     // ... data to create a Channels
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Channels we want to update
     *   }
     * })
    **/
    upsert<T extends channelsUpsertArgs>(
      args: SelectSubset<T, channelsUpsertArgs>
    ): CheckSelect<T, Prisma__channelsClient<channels>, Prisma__channelsClient<channelsGetPayload<T>>>

    /**
     * Count the number of Channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {channelsCountArgs} args - Arguments to filter Channels to count.
     * @example
     * // Count the number of Channels
     * const count = await prisma.channels.count({
     *   where: {
     *     // ... the filter for the Channels we want to count
     *   }
     * })
    **/
    count<T extends channelsCountArgs>(
      args?: Subset<T, channelsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChannelsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChannelsAggregateArgs>(args: Subset<T, ChannelsAggregateArgs>): PrismaPromise<GetChannelsAggregateType<T>>

    /**
     * Group by Channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChannelsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChannelsGroupByArgs['orderBy'] }
        : { orderBy?: ChannelsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChannelsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChannelsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for channels.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__channelsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    contacts_channels<T extends contacts_channelsFindManyArgs = {}>(args?: Subset<T, contacts_channelsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<contacts_channels>>, PrismaPromise<Array<contacts_channelsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * channels findUnique
   */
  export type channelsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the channels
     * 
    **/
    select?: channelsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: channelsInclude | null
    /**
     * Throw an Error if a channels can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which channels to fetch.
     * 
    **/
    where: channelsWhereUniqueInput
  }


  /**
   * channels findFirst
   */
  export type channelsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the channels
     * 
    **/
    select?: channelsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: channelsInclude | null
    /**
     * Throw an Error if a channels can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which channels to fetch.
     * 
    **/
    where?: channelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of channels to fetch.
     * 
    **/
    orderBy?: Enumerable<channelsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for channels.
     * 
    **/
    cursor?: channelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` channels from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` channels.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of channels.
     * 
    **/
    distinct?: Enumerable<ChannelsScalarFieldEnum>
  }


  /**
   * channels findMany
   */
  export type channelsFindManyArgs = {
    /**
     * Select specific fields to fetch from the channels
     * 
    **/
    select?: channelsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: channelsInclude | null
    /**
     * Filter, which channels to fetch.
     * 
    **/
    where?: channelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of channels to fetch.
     * 
    **/
    orderBy?: Enumerable<channelsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing channels.
     * 
    **/
    cursor?: channelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` channels from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` channels.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ChannelsScalarFieldEnum>
  }


  /**
   * channels create
   */
  export type channelsCreateArgs = {
    /**
     * Select specific fields to fetch from the channels
     * 
    **/
    select?: channelsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: channelsInclude | null
    /**
     * The data needed to create a channels.
     * 
    **/
    data: XOR<channelsCreateInput, channelsUncheckedCreateInput>
  }


  /**
   * channels createMany
   */
  export type channelsCreateManyArgs = {
    data: Enumerable<channelsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * channels update
   */
  export type channelsUpdateArgs = {
    /**
     * Select specific fields to fetch from the channels
     * 
    **/
    select?: channelsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: channelsInclude | null
    /**
     * The data needed to update a channels.
     * 
    **/
    data: XOR<channelsUpdateInput, channelsUncheckedUpdateInput>
    /**
     * Choose, which channels to update.
     * 
    **/
    where: channelsWhereUniqueInput
  }


  /**
   * channels updateMany
   */
  export type channelsUpdateManyArgs = {
    data: XOR<channelsUpdateManyMutationInput, channelsUncheckedUpdateManyInput>
    where?: channelsWhereInput
  }


  /**
   * channels upsert
   */
  export type channelsUpsertArgs = {
    /**
     * Select specific fields to fetch from the channels
     * 
    **/
    select?: channelsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: channelsInclude | null
    /**
     * The filter to search for the channels to update in case it exists.
     * 
    **/
    where: channelsWhereUniqueInput
    /**
     * In case the channels found by the `where` argument doesn't exist, create a new channels with this data.
     * 
    **/
    create: XOR<channelsCreateInput, channelsUncheckedCreateInput>
    /**
     * In case the channels was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<channelsUpdateInput, channelsUncheckedUpdateInput>
  }


  /**
   * channels delete
   */
  export type channelsDeleteArgs = {
    /**
     * Select specific fields to fetch from the channels
     * 
    **/
    select?: channelsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: channelsInclude | null
    /**
     * Filter which channels to delete.
     * 
    **/
    where: channelsWhereUniqueInput
  }


  /**
   * channels deleteMany
   */
  export type channelsDeleteManyArgs = {
    where?: channelsWhereInput
  }


  /**
   * channels without action
   */
  export type channelsArgs = {
    /**
     * Select specific fields to fetch from the channels
     * 
    **/
    select?: channelsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: channelsInclude | null
  }



  /**
   * Model cities
   */


  export type AggregateCities = {
    _count: CitiesCountAggregateOutputType | null
    _avg: CitiesAvgAggregateOutputType | null
    _sum: CitiesSumAggregateOutputType | null
    _min: CitiesMinAggregateOutputType | null
    _max: CitiesMaxAggregateOutputType | null
  }

  export type CitiesAvgAggregateOutputType = {
    id: number | null
    countries_id: number | null
  }

  export type CitiesSumAggregateOutputType = {
    id: number | null
    countries_id: number | null
  }

  export type CitiesMinAggregateOutputType = {
    id: number | null
    name: string | null
    countries_id: number | null
    isactive: boolean | null
  }

  export type CitiesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    countries_id: number | null
    isactive: boolean | null
  }

  export type CitiesCountAggregateOutputType = {
    id: number
    name: number
    countries_id: number
    isactive: number
    _all: number
  }


  export type CitiesAvgAggregateInputType = {
    id?: true
    countries_id?: true
  }

  export type CitiesSumAggregateInputType = {
    id?: true
    countries_id?: true
  }

  export type CitiesMinAggregateInputType = {
    id?: true
    name?: true
    countries_id?: true
    isactive?: true
  }

  export type CitiesMaxAggregateInputType = {
    id?: true
    name?: true
    countries_id?: true
    isactive?: true
  }

  export type CitiesCountAggregateInputType = {
    id?: true
    name?: true
    countries_id?: true
    isactive?: true
    _all?: true
  }

  export type CitiesAggregateArgs = {
    /**
     * Filter which cities to aggregate.
     * 
    **/
    where?: citiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities to fetch.
     * 
    **/
    orderBy?: Enumerable<citiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: citiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cities
    **/
    _count?: true | CitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CitiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CitiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CitiesMaxAggregateInputType
  }

  export type GetCitiesAggregateType<T extends CitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateCities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCities[P]>
      : GetScalarType<T[P], AggregateCities[P]>
  }


    
    
  export type CitiesGroupByArgs = {
    where?: citiesWhereInput
    orderBy?: Enumerable<citiesOrderByWithAggregationInput>
    by: Array<CitiesScalarFieldEnum>
    having?: citiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CitiesCountAggregateInputType | true
    _avg?: CitiesAvgAggregateInputType
    _sum?: CitiesSumAggregateInputType
    _min?: CitiesMinAggregateInputType
    _max?: CitiesMaxAggregateInputType
  }


  export type CitiesGroupByOutputType = {
    id: number
    name: string
    countries_id: number
    isactive: boolean | null
    _count: CitiesCountAggregateOutputType | null
    _avg: CitiesAvgAggregateOutputType | null
    _sum: CitiesSumAggregateOutputType | null
    _min: CitiesMinAggregateOutputType | null
    _max: CitiesMaxAggregateOutputType | null
  }

  type GetCitiesGroupByPayload<T extends CitiesGroupByArgs> = Promise<
    Array<
      PickArray<CitiesGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof CitiesGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], CitiesGroupByOutputType[P]> 
            : GetScalarType<T[P], CitiesGroupByOutputType[P]>
        }
      > 
    >


  export type citiesSelect = {
    id?: boolean
    name?: boolean
    countries_id?: boolean
    isactive?: boolean
    countries?: boolean | countriesArgs
    companies?: boolean | companiesFindManyArgs
    contacts?: boolean | contactsFindManyArgs
    _count?: boolean | CitiesCountOutputTypeArgs
  }

  export type citiesInclude = {
    countries?: boolean | countriesArgs
    companies?: boolean | companiesFindManyArgs
    contacts?: boolean | contactsFindManyArgs
    _count?: boolean | CitiesCountOutputTypeArgs
  }

  export type citiesGetPayload<
    S extends boolean | null | undefined | citiesArgs,
    U = keyof S
      > = S extends true
        ? cities
    : S extends undefined
    ? never
    : S extends citiesArgs | citiesFindManyArgs
    ?'include' extends U
    ? cities  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'countries'
        ? countriesGetPayload<S['include'][P]> :
        P extends 'companies'
        ? Array < companiesGetPayload<S['include'][P]>>  :
        P extends 'contacts'
        ? Array < contactsGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? CitiesCountOutputTypeGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof cities ?cities [P]
  : 
          P extends 'countries'
        ? countriesGetPayload<S['select'][P]> :
        P extends 'companies'
        ? Array < companiesGetPayload<S['select'][P]>>  :
        P extends 'contacts'
        ? Array < contactsGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? CitiesCountOutputTypeGetPayload<S['select'][P]> | null : never
  } 
    : cities
  : cities


  type citiesCountArgs = Merge<
    Omit<citiesFindManyArgs, 'select' | 'include'> & {
      select?: CitiesCountAggregateInputType | true
    }
  >

  export interface citiesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Cities that matches the filter.
     * @param {citiesFindUniqueArgs} args - Arguments to find a Cities
     * @example
     * // Get one Cities
     * const cities = await prisma.cities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends citiesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, citiesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'cities'> extends True ? CheckSelect<T, Prisma__citiesClient<cities>, Prisma__citiesClient<citiesGetPayload<T>>> : CheckSelect<T, Prisma__citiesClient<cities | null >, Prisma__citiesClient<citiesGetPayload<T> | null >>

    /**
     * Find the first Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {citiesFindFirstArgs} args - Arguments to find a Cities
     * @example
     * // Get one Cities
     * const cities = await prisma.cities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends citiesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, citiesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'cities'> extends True ? CheckSelect<T, Prisma__citiesClient<cities>, Prisma__citiesClient<citiesGetPayload<T>>> : CheckSelect<T, Prisma__citiesClient<cities | null >, Prisma__citiesClient<citiesGetPayload<T> | null >>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {citiesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.cities.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.cities.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const citiesWithIdOnly = await prisma.cities.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends citiesFindManyArgs>(
      args?: SelectSubset<T, citiesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<cities>>, PrismaPromise<Array<citiesGetPayload<T>>>>

    /**
     * Create a Cities.
     * @param {citiesCreateArgs} args - Arguments to create a Cities.
     * @example
     * // Create one Cities
     * const Cities = await prisma.cities.create({
     *   data: {
     *     // ... data to create a Cities
     *   }
     * })
     * 
    **/
    create<T extends citiesCreateArgs>(
      args: SelectSubset<T, citiesCreateArgs>
    ): CheckSelect<T, Prisma__citiesClient<cities>, Prisma__citiesClient<citiesGetPayload<T>>>

    /**
     * Create many Cities.
     *     @param {citiesCreateManyArgs} args - Arguments to create many Cities.
     *     @example
     *     // Create many Cities
     *     const cities = await prisma.cities.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends citiesCreateManyArgs>(
      args?: SelectSubset<T, citiesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Cities.
     * @param {citiesDeleteArgs} args - Arguments to delete one Cities.
     * @example
     * // Delete one Cities
     * const Cities = await prisma.cities.delete({
     *   where: {
     *     // ... filter to delete one Cities
     *   }
     * })
     * 
    **/
    delete<T extends citiesDeleteArgs>(
      args: SelectSubset<T, citiesDeleteArgs>
    ): CheckSelect<T, Prisma__citiesClient<cities>, Prisma__citiesClient<citiesGetPayload<T>>>

    /**
     * Update one Cities.
     * @param {citiesUpdateArgs} args - Arguments to update one Cities.
     * @example
     * // Update one Cities
     * const cities = await prisma.cities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends citiesUpdateArgs>(
      args: SelectSubset<T, citiesUpdateArgs>
    ): CheckSelect<T, Prisma__citiesClient<cities>, Prisma__citiesClient<citiesGetPayload<T>>>

    /**
     * Delete zero or more Cities.
     * @param {citiesDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.cities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends citiesDeleteManyArgs>(
      args?: SelectSubset<T, citiesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {citiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const cities = await prisma.cities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends citiesUpdateManyArgs>(
      args: SelectSubset<T, citiesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Cities.
     * @param {citiesUpsertArgs} args - Arguments to update or create a Cities.
     * @example
     * // Update or create a Cities
     * const cities = await prisma.cities.upsert({
     *   create: {
     *     // ... data to create a Cities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cities we want to update
     *   }
     * })
    **/
    upsert<T extends citiesUpsertArgs>(
      args: SelectSubset<T, citiesUpsertArgs>
    ): CheckSelect<T, Prisma__citiesClient<cities>, Prisma__citiesClient<citiesGetPayload<T>>>

    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {citiesCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.cities.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends citiesCountArgs>(
      args?: Subset<T, citiesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CitiesAggregateArgs>(args: Subset<T, CitiesAggregateArgs>): PrismaPromise<GetCitiesAggregateType<T>>

    /**
     * Group by Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CitiesGroupByArgs['orderBy'] }
        : { orderBy?: CitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCitiesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for cities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__citiesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    countries<T extends countriesArgs = {}>(args?: Subset<T, countriesArgs>): CheckSelect<T, Prisma__countriesClient<countries | null >, Prisma__countriesClient<countriesGetPayload<T> | null >>;

    companies<T extends companiesFindManyArgs = {}>(args?: Subset<T, companiesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<companies>>, PrismaPromise<Array<companiesGetPayload<T>>>>;

    contacts<T extends contactsFindManyArgs = {}>(args?: Subset<T, contactsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<contacts>>, PrismaPromise<Array<contactsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * cities findUnique
   */
  export type citiesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the cities
     * 
    **/
    select?: citiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: citiesInclude | null
    /**
     * Throw an Error if a cities can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which cities to fetch.
     * 
    **/
    where: citiesWhereUniqueInput
  }


  /**
   * cities findFirst
   */
  export type citiesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the cities
     * 
    **/
    select?: citiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: citiesInclude | null
    /**
     * Throw an Error if a cities can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which cities to fetch.
     * 
    **/
    where?: citiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities to fetch.
     * 
    **/
    orderBy?: Enumerable<citiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cities.
     * 
    **/
    cursor?: citiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cities.
     * 
    **/
    distinct?: Enumerable<CitiesScalarFieldEnum>
  }


  /**
   * cities findMany
   */
  export type citiesFindManyArgs = {
    /**
     * Select specific fields to fetch from the cities
     * 
    **/
    select?: citiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: citiesInclude | null
    /**
     * Filter, which cities to fetch.
     * 
    **/
    where?: citiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities to fetch.
     * 
    **/
    orderBy?: Enumerable<citiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cities.
     * 
    **/
    cursor?: citiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CitiesScalarFieldEnum>
  }


  /**
   * cities create
   */
  export type citiesCreateArgs = {
    /**
     * Select specific fields to fetch from the cities
     * 
    **/
    select?: citiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: citiesInclude | null
    /**
     * The data needed to create a cities.
     * 
    **/
    data: XOR<citiesCreateInput, citiesUncheckedCreateInput>
  }


  /**
   * cities createMany
   */
  export type citiesCreateManyArgs = {
    data: Enumerable<citiesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * cities update
   */
  export type citiesUpdateArgs = {
    /**
     * Select specific fields to fetch from the cities
     * 
    **/
    select?: citiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: citiesInclude | null
    /**
     * The data needed to update a cities.
     * 
    **/
    data: XOR<citiesUpdateInput, citiesUncheckedUpdateInput>
    /**
     * Choose, which cities to update.
     * 
    **/
    where: citiesWhereUniqueInput
  }


  /**
   * cities updateMany
   */
  export type citiesUpdateManyArgs = {
    data: XOR<citiesUpdateManyMutationInput, citiesUncheckedUpdateManyInput>
    where?: citiesWhereInput
  }


  /**
   * cities upsert
   */
  export type citiesUpsertArgs = {
    /**
     * Select specific fields to fetch from the cities
     * 
    **/
    select?: citiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: citiesInclude | null
    /**
     * The filter to search for the cities to update in case it exists.
     * 
    **/
    where: citiesWhereUniqueInput
    /**
     * In case the cities found by the `where` argument doesn't exist, create a new cities with this data.
     * 
    **/
    create: XOR<citiesCreateInput, citiesUncheckedCreateInput>
    /**
     * In case the cities was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<citiesUpdateInput, citiesUncheckedUpdateInput>
  }


  /**
   * cities delete
   */
  export type citiesDeleteArgs = {
    /**
     * Select specific fields to fetch from the cities
     * 
    **/
    select?: citiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: citiesInclude | null
    /**
     * Filter which cities to delete.
     * 
    **/
    where: citiesWhereUniqueInput
  }


  /**
   * cities deleteMany
   */
  export type citiesDeleteManyArgs = {
    where?: citiesWhereInput
  }


  /**
   * cities without action
   */
  export type citiesArgs = {
    /**
     * Select specific fields to fetch from the cities
     * 
    **/
    select?: citiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: citiesInclude | null
  }



  /**
   * Model companies
   */


  export type AggregateCompanies = {
    _count: CompaniesCountAggregateOutputType | null
    _avg: CompaniesAvgAggregateOutputType | null
    _sum: CompaniesSumAggregateOutputType | null
    _min: CompaniesMinAggregateOutputType | null
    _max: CompaniesMaxAggregateOutputType | null
  }

  export type CompaniesAvgAggregateOutputType = {
    id: number | null
    cities_id: number | null
  }

  export type CompaniesSumAggregateOutputType = {
    id: number | null
    cities_id: number | null
  }

  export type CompaniesMinAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    email: string | null
    phone: string | null
    cities_id: number | null
    isactive: boolean | null
  }

  export type CompaniesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    email: string | null
    phone: string | null
    cities_id: number | null
    isactive: boolean | null
  }

  export type CompaniesCountAggregateOutputType = {
    id: number
    name: number
    address: number
    email: number
    phone: number
    cities_id: number
    isactive: number
    _all: number
  }


  export type CompaniesAvgAggregateInputType = {
    id?: true
    cities_id?: true
  }

  export type CompaniesSumAggregateInputType = {
    id?: true
    cities_id?: true
  }

  export type CompaniesMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    email?: true
    phone?: true
    cities_id?: true
    isactive?: true
  }

  export type CompaniesMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    email?: true
    phone?: true
    cities_id?: true
    isactive?: true
  }

  export type CompaniesCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    email?: true
    phone?: true
    cities_id?: true
    isactive?: true
    _all?: true
  }

  export type CompaniesAggregateArgs = {
    /**
     * Filter which companies to aggregate.
     * 
    **/
    where?: companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     * 
    **/
    orderBy?: Enumerable<companiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned companies
    **/
    _count?: true | CompaniesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompaniesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompaniesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompaniesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompaniesMaxAggregateInputType
  }

  export type GetCompaniesAggregateType<T extends CompaniesAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanies[P]>
      : GetScalarType<T[P], AggregateCompanies[P]>
  }


    
    
  export type CompaniesGroupByArgs = {
    where?: companiesWhereInput
    orderBy?: Enumerable<companiesOrderByWithAggregationInput>
    by: Array<CompaniesScalarFieldEnum>
    having?: companiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompaniesCountAggregateInputType | true
    _avg?: CompaniesAvgAggregateInputType
    _sum?: CompaniesSumAggregateInputType
    _min?: CompaniesMinAggregateInputType
    _max?: CompaniesMaxAggregateInputType
  }


  export type CompaniesGroupByOutputType = {
    id: number
    name: string
    address: string
    email: string
    phone: string
    cities_id: number
    isactive: boolean | null
    _count: CompaniesCountAggregateOutputType | null
    _avg: CompaniesAvgAggregateOutputType | null
    _sum: CompaniesSumAggregateOutputType | null
    _min: CompaniesMinAggregateOutputType | null
    _max: CompaniesMaxAggregateOutputType | null
  }

  type GetCompaniesGroupByPayload<T extends CompaniesGroupByArgs> = Promise<
    Array<
      PickArray<CompaniesGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof CompaniesGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], CompaniesGroupByOutputType[P]> 
            : GetScalarType<T[P], CompaniesGroupByOutputType[P]>
        }
      > 
    >


  export type companiesSelect = {
    id?: boolean
    name?: boolean
    address?: boolean
    email?: boolean
    phone?: boolean
    cities_id?: boolean
    isactive?: boolean
    cities?: boolean | citiesArgs
    contacts?: boolean | contactsFindManyArgs
    _count?: boolean | CompaniesCountOutputTypeArgs
  }

  export type companiesInclude = {
    cities?: boolean | citiesArgs
    contacts?: boolean | contactsFindManyArgs
    _count?: boolean | CompaniesCountOutputTypeArgs
  }

  export type companiesGetPayload<
    S extends boolean | null | undefined | companiesArgs,
    U = keyof S
      > = S extends true
        ? companies
    : S extends undefined
    ? never
    : S extends companiesArgs | companiesFindManyArgs
    ?'include' extends U
    ? companies  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'cities'
        ? citiesGetPayload<S['include'][P]> :
        P extends 'contacts'
        ? Array < contactsGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? CompaniesCountOutputTypeGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof companies ?companies [P]
  : 
          P extends 'cities'
        ? citiesGetPayload<S['select'][P]> :
        P extends 'contacts'
        ? Array < contactsGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? CompaniesCountOutputTypeGetPayload<S['select'][P]> | null : never
  } 
    : companies
  : companies


  type companiesCountArgs = Merge<
    Omit<companiesFindManyArgs, 'select' | 'include'> & {
      select?: CompaniesCountAggregateInputType | true
    }
  >

  export interface companiesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Companies that matches the filter.
     * @param {companiesFindUniqueArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends companiesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, companiesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'companies'> extends True ? CheckSelect<T, Prisma__companiesClient<companies>, Prisma__companiesClient<companiesGetPayload<T>>> : CheckSelect<T, Prisma__companiesClient<companies | null >, Prisma__companiesClient<companiesGetPayload<T> | null >>

    /**
     * Find the first Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesFindFirstArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends companiesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, companiesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'companies'> extends True ? CheckSelect<T, Prisma__companiesClient<companies>, Prisma__companiesClient<companiesGetPayload<T>>> : CheckSelect<T, Prisma__companiesClient<companies | null >, Prisma__companiesClient<companiesGetPayload<T> | null >>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.companies.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.companies.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companiesWithIdOnly = await prisma.companies.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends companiesFindManyArgs>(
      args?: SelectSubset<T, companiesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<companies>>, PrismaPromise<Array<companiesGetPayload<T>>>>

    /**
     * Create a Companies.
     * @param {companiesCreateArgs} args - Arguments to create a Companies.
     * @example
     * // Create one Companies
     * const Companies = await prisma.companies.create({
     *   data: {
     *     // ... data to create a Companies
     *   }
     * })
     * 
    **/
    create<T extends companiesCreateArgs>(
      args: SelectSubset<T, companiesCreateArgs>
    ): CheckSelect<T, Prisma__companiesClient<companies>, Prisma__companiesClient<companiesGetPayload<T>>>

    /**
     * Create many Companies.
     *     @param {companiesCreateManyArgs} args - Arguments to create many Companies.
     *     @example
     *     // Create many Companies
     *     const companies = await prisma.companies.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends companiesCreateManyArgs>(
      args?: SelectSubset<T, companiesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Companies.
     * @param {companiesDeleteArgs} args - Arguments to delete one Companies.
     * @example
     * // Delete one Companies
     * const Companies = await prisma.companies.delete({
     *   where: {
     *     // ... filter to delete one Companies
     *   }
     * })
     * 
    **/
    delete<T extends companiesDeleteArgs>(
      args: SelectSubset<T, companiesDeleteArgs>
    ): CheckSelect<T, Prisma__companiesClient<companies>, Prisma__companiesClient<companiesGetPayload<T>>>

    /**
     * Update one Companies.
     * @param {companiesUpdateArgs} args - Arguments to update one Companies.
     * @example
     * // Update one Companies
     * const companies = await prisma.companies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends companiesUpdateArgs>(
      args: SelectSubset<T, companiesUpdateArgs>
    ): CheckSelect<T, Prisma__companiesClient<companies>, Prisma__companiesClient<companiesGetPayload<T>>>

    /**
     * Delete zero or more Companies.
     * @param {companiesDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.companies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends companiesDeleteManyArgs>(
      args?: SelectSubset<T, companiesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const companies = await prisma.companies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends companiesUpdateManyArgs>(
      args: SelectSubset<T, companiesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Companies.
     * @param {companiesUpsertArgs} args - Arguments to update or create a Companies.
     * @example
     * // Update or create a Companies
     * const companies = await prisma.companies.upsert({
     *   create: {
     *     // ... data to create a Companies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Companies we want to update
     *   }
     * })
    **/
    upsert<T extends companiesUpsertArgs>(
      args: SelectSubset<T, companiesUpsertArgs>
    ): CheckSelect<T, Prisma__companiesClient<companies>, Prisma__companiesClient<companiesGetPayload<T>>>

    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.companies.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends companiesCountArgs>(
      args?: Subset<T, companiesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompaniesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompaniesAggregateArgs>(args: Subset<T, CompaniesAggregateArgs>): PrismaPromise<GetCompaniesAggregateType<T>>

    /**
     * Group by Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompaniesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompaniesGroupByArgs['orderBy'] }
        : { orderBy?: CompaniesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompaniesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompaniesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for companies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__companiesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    cities<T extends citiesArgs = {}>(args?: Subset<T, citiesArgs>): CheckSelect<T, Prisma__citiesClient<cities | null >, Prisma__citiesClient<citiesGetPayload<T> | null >>;

    contacts<T extends contactsFindManyArgs = {}>(args?: Subset<T, contactsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<contacts>>, PrismaPromise<Array<contactsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * companies findUnique
   */
  export type companiesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the companies
     * 
    **/
    select?: companiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companiesInclude | null
    /**
     * Throw an Error if a companies can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which companies to fetch.
     * 
    **/
    where: companiesWhereUniqueInput
  }


  /**
   * companies findFirst
   */
  export type companiesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the companies
     * 
    **/
    select?: companiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companiesInclude | null
    /**
     * Throw an Error if a companies can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which companies to fetch.
     * 
    **/
    where?: companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     * 
    **/
    orderBy?: Enumerable<companiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companies.
     * 
    **/
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companies.
     * 
    **/
    distinct?: Enumerable<CompaniesScalarFieldEnum>
  }


  /**
   * companies findMany
   */
  export type companiesFindManyArgs = {
    /**
     * Select specific fields to fetch from the companies
     * 
    **/
    select?: companiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companiesInclude | null
    /**
     * Filter, which companies to fetch.
     * 
    **/
    where?: companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     * 
    **/
    orderBy?: Enumerable<companiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing companies.
     * 
    **/
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CompaniesScalarFieldEnum>
  }


  /**
   * companies create
   */
  export type companiesCreateArgs = {
    /**
     * Select specific fields to fetch from the companies
     * 
    **/
    select?: companiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companiesInclude | null
    /**
     * The data needed to create a companies.
     * 
    **/
    data: XOR<companiesCreateInput, companiesUncheckedCreateInput>
  }


  /**
   * companies createMany
   */
  export type companiesCreateManyArgs = {
    data: Enumerable<companiesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * companies update
   */
  export type companiesUpdateArgs = {
    /**
     * Select specific fields to fetch from the companies
     * 
    **/
    select?: companiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companiesInclude | null
    /**
     * The data needed to update a companies.
     * 
    **/
    data: XOR<companiesUpdateInput, companiesUncheckedUpdateInput>
    /**
     * Choose, which companies to update.
     * 
    **/
    where: companiesWhereUniqueInput
  }


  /**
   * companies updateMany
   */
  export type companiesUpdateManyArgs = {
    data: XOR<companiesUpdateManyMutationInput, companiesUncheckedUpdateManyInput>
    where?: companiesWhereInput
  }


  /**
   * companies upsert
   */
  export type companiesUpsertArgs = {
    /**
     * Select specific fields to fetch from the companies
     * 
    **/
    select?: companiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companiesInclude | null
    /**
     * The filter to search for the companies to update in case it exists.
     * 
    **/
    where: companiesWhereUniqueInput
    /**
     * In case the companies found by the `where` argument doesn't exist, create a new companies with this data.
     * 
    **/
    create: XOR<companiesCreateInput, companiesUncheckedCreateInput>
    /**
     * In case the companies was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<companiesUpdateInput, companiesUncheckedUpdateInput>
  }


  /**
   * companies delete
   */
  export type companiesDeleteArgs = {
    /**
     * Select specific fields to fetch from the companies
     * 
    **/
    select?: companiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companiesInclude | null
    /**
     * Filter which companies to delete.
     * 
    **/
    where: companiesWhereUniqueInput
  }


  /**
   * companies deleteMany
   */
  export type companiesDeleteManyArgs = {
    where?: companiesWhereInput
  }


  /**
   * companies without action
   */
  export type companiesArgs = {
    /**
     * Select specific fields to fetch from the companies
     * 
    **/
    select?: companiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companiesInclude | null
  }



  /**
   * Model contacts
   */


  export type AggregateContacts = {
    _count: ContactsCountAggregateOutputType | null
    _avg: ContactsAvgAggregateOutputType | null
    _sum: ContactsSumAggregateOutputType | null
    _min: ContactsMinAggregateOutputType | null
    _max: ContactsMaxAggregateOutputType | null
  }

  export type ContactsAvgAggregateOutputType = {
    id: number | null
    interest: number | null
    users_id: number | null
    companies_id: number | null
    cities_id: number | null
  }

  export type ContactsSumAggregateOutputType = {
    id: number | null
    interest: number | null
    users_id: number | null
    companies_id: number | null
    cities_id: number | null
  }

  export type ContactsMinAggregateOutputType = {
    id: number | null
    username: string | null
    lastname: string | null
    email: string | null
    job_tittle: string | null
    create_time: Date | null
    address: string | null
    interest: number | null
    imgUrl: string | null
    users_id: number | null
    companies_id: number | null
    cities_id: number | null
    isactive: boolean | null
  }

  export type ContactsMaxAggregateOutputType = {
    id: number | null
    username: string | null
    lastname: string | null
    email: string | null
    job_tittle: string | null
    create_time: Date | null
    address: string | null
    interest: number | null
    imgUrl: string | null
    users_id: number | null
    companies_id: number | null
    cities_id: number | null
    isactive: boolean | null
  }

  export type ContactsCountAggregateOutputType = {
    id: number
    username: number
    lastname: number
    email: number
    job_tittle: number
    create_time: number
    address: number
    interest: number
    imgUrl: number
    users_id: number
    companies_id: number
    cities_id: number
    isactive: number
    _all: number
  }


  export type ContactsAvgAggregateInputType = {
    id?: true
    interest?: true
    users_id?: true
    companies_id?: true
    cities_id?: true
  }

  export type ContactsSumAggregateInputType = {
    id?: true
    interest?: true
    users_id?: true
    companies_id?: true
    cities_id?: true
  }

  export type ContactsMinAggregateInputType = {
    id?: true
    username?: true
    lastname?: true
    email?: true
    job_tittle?: true
    create_time?: true
    address?: true
    interest?: true
    imgUrl?: true
    users_id?: true
    companies_id?: true
    cities_id?: true
    isactive?: true
  }

  export type ContactsMaxAggregateInputType = {
    id?: true
    username?: true
    lastname?: true
    email?: true
    job_tittle?: true
    create_time?: true
    address?: true
    interest?: true
    imgUrl?: true
    users_id?: true
    companies_id?: true
    cities_id?: true
    isactive?: true
  }

  export type ContactsCountAggregateInputType = {
    id?: true
    username?: true
    lastname?: true
    email?: true
    job_tittle?: true
    create_time?: true
    address?: true
    interest?: true
    imgUrl?: true
    users_id?: true
    companies_id?: true
    cities_id?: true
    isactive?: true
    _all?: true
  }

  export type ContactsAggregateArgs = {
    /**
     * Filter which contacts to aggregate.
     * 
    **/
    where?: contactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts to fetch.
     * 
    **/
    orderBy?: Enumerable<contactsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: contactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned contacts
    **/
    _count?: true | ContactsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactsMaxAggregateInputType
  }

  export type GetContactsAggregateType<T extends ContactsAggregateArgs> = {
        [P in keyof T & keyof AggregateContacts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContacts[P]>
      : GetScalarType<T[P], AggregateContacts[P]>
  }


    
    
  export type ContactsGroupByArgs = {
    where?: contactsWhereInput
    orderBy?: Enumerable<contactsOrderByWithAggregationInput>
    by: Array<ContactsScalarFieldEnum>
    having?: contactsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactsCountAggregateInputType | true
    _avg?: ContactsAvgAggregateInputType
    _sum?: ContactsSumAggregateInputType
    _min?: ContactsMinAggregateInputType
    _max?: ContactsMaxAggregateInputType
  }


  export type ContactsGroupByOutputType = {
    id: number
    username: string
    lastname: string
    email: string
    job_tittle: string
    create_time: Date | null
    address: string | null
    interest: number | null
    imgUrl: string | null
    users_id: number
    companies_id: number
    cities_id: number
    isactive: boolean | null
    _count: ContactsCountAggregateOutputType | null
    _avg: ContactsAvgAggregateOutputType | null
    _sum: ContactsSumAggregateOutputType | null
    _min: ContactsMinAggregateOutputType | null
    _max: ContactsMaxAggregateOutputType | null
  }

  type GetContactsGroupByPayload<T extends ContactsGroupByArgs> = Promise<
    Array<
      PickArray<ContactsGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof ContactsGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], ContactsGroupByOutputType[P]> 
            : GetScalarType<T[P], ContactsGroupByOutputType[P]>
        }
      > 
    >


  export type contactsSelect = {
    id?: boolean
    username?: boolean
    lastname?: boolean
    email?: boolean
    job_tittle?: boolean
    create_time?: boolean
    address?: boolean
    interest?: boolean
    imgUrl?: boolean
    users_id?: boolean
    companies_id?: boolean
    cities_id?: boolean
    isactive?: boolean
    cities?: boolean | citiesArgs
    companies?: boolean | companiesArgs
    users?: boolean | usersArgs
    contacts_channels?: boolean | contacts_channelsFindManyArgs
    _count?: boolean | ContactsCountOutputTypeArgs
  }

  export type contactsInclude = {
    cities?: boolean | citiesArgs
    companies?: boolean | companiesArgs
    users?: boolean | usersArgs
    contacts_channels?: boolean | contacts_channelsFindManyArgs
    _count?: boolean | ContactsCountOutputTypeArgs
  }

  export type contactsGetPayload<
    S extends boolean | null | undefined | contactsArgs,
    U = keyof S
      > = S extends true
        ? contacts
    : S extends undefined
    ? never
    : S extends contactsArgs | contactsFindManyArgs
    ?'include' extends U
    ? contacts  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'cities'
        ? citiesGetPayload<S['include'][P]> :
        P extends 'companies'
        ? companiesGetPayload<S['include'][P]> :
        P extends 'users'
        ? usersGetPayload<S['include'][P]> :
        P extends 'contacts_channels'
        ? Array < contacts_channelsGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? ContactsCountOutputTypeGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof contacts ?contacts [P]
  : 
          P extends 'cities'
        ? citiesGetPayload<S['select'][P]> :
        P extends 'companies'
        ? companiesGetPayload<S['select'][P]> :
        P extends 'users'
        ? usersGetPayload<S['select'][P]> :
        P extends 'contacts_channels'
        ? Array < contacts_channelsGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? ContactsCountOutputTypeGetPayload<S['select'][P]> | null : never
  } 
    : contacts
  : contacts


  type contactsCountArgs = Merge<
    Omit<contactsFindManyArgs, 'select' | 'include'> & {
      select?: ContactsCountAggregateInputType | true
    }
  >

  export interface contactsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Contacts that matches the filter.
     * @param {contactsFindUniqueArgs} args - Arguments to find a Contacts
     * @example
     * // Get one Contacts
     * const contacts = await prisma.contacts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends contactsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, contactsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'contacts'> extends True ? CheckSelect<T, Prisma__contactsClient<contacts>, Prisma__contactsClient<contactsGetPayload<T>>> : CheckSelect<T, Prisma__contactsClient<contacts | null >, Prisma__contactsClient<contactsGetPayload<T> | null >>

    /**
     * Find the first Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactsFindFirstArgs} args - Arguments to find a Contacts
     * @example
     * // Get one Contacts
     * const contacts = await prisma.contacts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends contactsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, contactsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'contacts'> extends True ? CheckSelect<T, Prisma__contactsClient<contacts>, Prisma__contactsClient<contactsGetPayload<T>>> : CheckSelect<T, Prisma__contactsClient<contacts | null >, Prisma__contactsClient<contactsGetPayload<T> | null >>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contacts.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contacts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactsWithIdOnly = await prisma.contacts.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends contactsFindManyArgs>(
      args?: SelectSubset<T, contactsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<contacts>>, PrismaPromise<Array<contactsGetPayload<T>>>>

    /**
     * Create a Contacts.
     * @param {contactsCreateArgs} args - Arguments to create a Contacts.
     * @example
     * // Create one Contacts
     * const Contacts = await prisma.contacts.create({
     *   data: {
     *     // ... data to create a Contacts
     *   }
     * })
     * 
    **/
    create<T extends contactsCreateArgs>(
      args: SelectSubset<T, contactsCreateArgs>
    ): CheckSelect<T, Prisma__contactsClient<contacts>, Prisma__contactsClient<contactsGetPayload<T>>>

    /**
     * Create many Contacts.
     *     @param {contactsCreateManyArgs} args - Arguments to create many Contacts.
     *     @example
     *     // Create many Contacts
     *     const contacts = await prisma.contacts.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends contactsCreateManyArgs>(
      args?: SelectSubset<T, contactsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Contacts.
     * @param {contactsDeleteArgs} args - Arguments to delete one Contacts.
     * @example
     * // Delete one Contacts
     * const Contacts = await prisma.contacts.delete({
     *   where: {
     *     // ... filter to delete one Contacts
     *   }
     * })
     * 
    **/
    delete<T extends contactsDeleteArgs>(
      args: SelectSubset<T, contactsDeleteArgs>
    ): CheckSelect<T, Prisma__contactsClient<contacts>, Prisma__contactsClient<contactsGetPayload<T>>>

    /**
     * Update one Contacts.
     * @param {contactsUpdateArgs} args - Arguments to update one Contacts.
     * @example
     * // Update one Contacts
     * const contacts = await prisma.contacts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends contactsUpdateArgs>(
      args: SelectSubset<T, contactsUpdateArgs>
    ): CheckSelect<T, Prisma__contactsClient<contacts>, Prisma__contactsClient<contactsGetPayload<T>>>

    /**
     * Delete zero or more Contacts.
     * @param {contactsDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contacts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends contactsDeleteManyArgs>(
      args?: SelectSubset<T, contactsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contacts = await prisma.contacts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends contactsUpdateManyArgs>(
      args: SelectSubset<T, contactsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Contacts.
     * @param {contactsUpsertArgs} args - Arguments to update or create a Contacts.
     * @example
     * // Update or create a Contacts
     * const contacts = await prisma.contacts.upsert({
     *   create: {
     *     // ... data to create a Contacts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contacts we want to update
     *   }
     * })
    **/
    upsert<T extends contactsUpsertArgs>(
      args: SelectSubset<T, contactsUpsertArgs>
    ): CheckSelect<T, Prisma__contactsClient<contacts>, Prisma__contactsClient<contactsGetPayload<T>>>

    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactsCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contacts.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends contactsCountArgs>(
      args?: Subset<T, contactsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactsAggregateArgs>(args: Subset<T, ContactsAggregateArgs>): PrismaPromise<GetContactsAggregateType<T>>

    /**
     * Group by Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactsGroupByArgs['orderBy'] }
        : { orderBy?: ContactsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for contacts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__contactsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    cities<T extends citiesArgs = {}>(args?: Subset<T, citiesArgs>): CheckSelect<T, Prisma__citiesClient<cities | null >, Prisma__citiesClient<citiesGetPayload<T> | null >>;

    companies<T extends companiesArgs = {}>(args?: Subset<T, companiesArgs>): CheckSelect<T, Prisma__companiesClient<companies | null >, Prisma__companiesClient<companiesGetPayload<T> | null >>;

    users<T extends usersArgs = {}>(args?: Subset<T, usersArgs>): CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>;

    contacts_channels<T extends contacts_channelsFindManyArgs = {}>(args?: Subset<T, contacts_channelsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<contacts_channels>>, PrismaPromise<Array<contacts_channelsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * contacts findUnique
   */
  export type contactsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the contacts
     * 
    **/
    select?: contactsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: contactsInclude | null
    /**
     * Throw an Error if a contacts can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which contacts to fetch.
     * 
    **/
    where: contactsWhereUniqueInput
  }


  /**
   * contacts findFirst
   */
  export type contactsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the contacts
     * 
    **/
    select?: contactsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: contactsInclude | null
    /**
     * Throw an Error if a contacts can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which contacts to fetch.
     * 
    **/
    where?: contactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts to fetch.
     * 
    **/
    orderBy?: Enumerable<contactsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contacts.
     * 
    **/
    cursor?: contactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contacts.
     * 
    **/
    distinct?: Enumerable<ContactsScalarFieldEnum>
  }


  /**
   * contacts findMany
   */
  export type contactsFindManyArgs = {
    /**
     * Select specific fields to fetch from the contacts
     * 
    **/
    select?: contactsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: contactsInclude | null
    /**
     * Filter, which contacts to fetch.
     * 
    **/
    where?: contactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts to fetch.
     * 
    **/
    orderBy?: Enumerable<contactsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing contacts.
     * 
    **/
    cursor?: contactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ContactsScalarFieldEnum>
  }


  /**
   * contacts create
   */
  export type contactsCreateArgs = {
    /**
     * Select specific fields to fetch from the contacts
     * 
    **/
    select?: contactsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: contactsInclude | null
    /**
     * The data needed to create a contacts.
     * 
    **/
    data: XOR<contactsCreateInput, contactsUncheckedCreateInput>
  }


  /**
   * contacts createMany
   */
  export type contactsCreateManyArgs = {
    data: Enumerable<contactsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * contacts update
   */
  export type contactsUpdateArgs = {
    /**
     * Select specific fields to fetch from the contacts
     * 
    **/
    select?: contactsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: contactsInclude | null
    /**
     * The data needed to update a contacts.
     * 
    **/
    data: XOR<contactsUpdateInput, contactsUncheckedUpdateInput>
    /**
     * Choose, which contacts to update.
     * 
    **/
    where: contactsWhereUniqueInput
  }


  /**
   * contacts updateMany
   */
  export type contactsUpdateManyArgs = {
    data: XOR<contactsUpdateManyMutationInput, contactsUncheckedUpdateManyInput>
    where?: contactsWhereInput
  }


  /**
   * contacts upsert
   */
  export type contactsUpsertArgs = {
    /**
     * Select specific fields to fetch from the contacts
     * 
    **/
    select?: contactsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: contactsInclude | null
    /**
     * The filter to search for the contacts to update in case it exists.
     * 
    **/
    where: contactsWhereUniqueInput
    /**
     * In case the contacts found by the `where` argument doesn't exist, create a new contacts with this data.
     * 
    **/
    create: XOR<contactsCreateInput, contactsUncheckedCreateInput>
    /**
     * In case the contacts was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<contactsUpdateInput, contactsUncheckedUpdateInput>
  }


  /**
   * contacts delete
   */
  export type contactsDeleteArgs = {
    /**
     * Select specific fields to fetch from the contacts
     * 
    **/
    select?: contactsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: contactsInclude | null
    /**
     * Filter which contacts to delete.
     * 
    **/
    where: contactsWhereUniqueInput
  }


  /**
   * contacts deleteMany
   */
  export type contactsDeleteManyArgs = {
    where?: contactsWhereInput
  }


  /**
   * contacts without action
   */
  export type contactsArgs = {
    /**
     * Select specific fields to fetch from the contacts
     * 
    **/
    select?: contactsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: contactsInclude | null
  }



  /**
   * Model contacts_channels
   */


  export type AggregateContacts_channels = {
    _count: Contacts_channelsCountAggregateOutputType | null
    _avg: Contacts_channelsAvgAggregateOutputType | null
    _sum: Contacts_channelsSumAggregateOutputType | null
    _min: Contacts_channelsMinAggregateOutputType | null
    _max: Contacts_channelsMaxAggregateOutputType | null
  }

  export type Contacts_channelsAvgAggregateOutputType = {
    id: number | null
    channels_id: number | null
    preferences_id: number | null
    contacts_id: number | null
  }

  export type Contacts_channelsSumAggregateOutputType = {
    id: number | null
    channels_id: number | null
    preferences_id: number | null
    contacts_id: number | null
  }

  export type Contacts_channelsMinAggregateOutputType = {
    id: number | null
    acount: string | null
    channels_id: number | null
    preferences_id: number | null
    contacts_id: number | null
  }

  export type Contacts_channelsMaxAggregateOutputType = {
    id: number | null
    acount: string | null
    channels_id: number | null
    preferences_id: number | null
    contacts_id: number | null
  }

  export type Contacts_channelsCountAggregateOutputType = {
    id: number
    acount: number
    channels_id: number
    preferences_id: number
    contacts_id: number
    _all: number
  }


  export type Contacts_channelsAvgAggregateInputType = {
    id?: true
    channels_id?: true
    preferences_id?: true
    contacts_id?: true
  }

  export type Contacts_channelsSumAggregateInputType = {
    id?: true
    channels_id?: true
    preferences_id?: true
    contacts_id?: true
  }

  export type Contacts_channelsMinAggregateInputType = {
    id?: true
    acount?: true
    channels_id?: true
    preferences_id?: true
    contacts_id?: true
  }

  export type Contacts_channelsMaxAggregateInputType = {
    id?: true
    acount?: true
    channels_id?: true
    preferences_id?: true
    contacts_id?: true
  }

  export type Contacts_channelsCountAggregateInputType = {
    id?: true
    acount?: true
    channels_id?: true
    preferences_id?: true
    contacts_id?: true
    _all?: true
  }

  export type Contacts_channelsAggregateArgs = {
    /**
     * Filter which contacts_channels to aggregate.
     * 
    **/
    where?: contacts_channelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts_channels to fetch.
     * 
    **/
    orderBy?: Enumerable<contacts_channelsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: contacts_channelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts_channels from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts_channels.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned contacts_channels
    **/
    _count?: true | Contacts_channelsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Contacts_channelsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Contacts_channelsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Contacts_channelsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Contacts_channelsMaxAggregateInputType
  }

  export type GetContacts_channelsAggregateType<T extends Contacts_channelsAggregateArgs> = {
        [P in keyof T & keyof AggregateContacts_channels]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContacts_channels[P]>
      : GetScalarType<T[P], AggregateContacts_channels[P]>
  }


    
    
  export type Contacts_channelsGroupByArgs = {
    where?: contacts_channelsWhereInput
    orderBy?: Enumerable<contacts_channelsOrderByWithAggregationInput>
    by: Array<Contacts_channelsScalarFieldEnum>
    having?: contacts_channelsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Contacts_channelsCountAggregateInputType | true
    _avg?: Contacts_channelsAvgAggregateInputType
    _sum?: Contacts_channelsSumAggregateInputType
    _min?: Contacts_channelsMinAggregateInputType
    _max?: Contacts_channelsMaxAggregateInputType
  }


  export type Contacts_channelsGroupByOutputType = {
    id: number
    acount: string
    channels_id: number
    preferences_id: number
    contacts_id: number
    _count: Contacts_channelsCountAggregateOutputType | null
    _avg: Contacts_channelsAvgAggregateOutputType | null
    _sum: Contacts_channelsSumAggregateOutputType | null
    _min: Contacts_channelsMinAggregateOutputType | null
    _max: Contacts_channelsMaxAggregateOutputType | null
  }

  type GetContacts_channelsGroupByPayload<T extends Contacts_channelsGroupByArgs> = Promise<
    Array<
      PickArray<Contacts_channelsGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof Contacts_channelsGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], Contacts_channelsGroupByOutputType[P]> 
            : GetScalarType<T[P], Contacts_channelsGroupByOutputType[P]>
        }
      > 
    >


  export type contacts_channelsSelect = {
    id?: boolean
    acount?: boolean
    channels_id?: boolean
    preferences_id?: boolean
    contacts_id?: boolean
    channels?: boolean | channelsArgs
    contacts?: boolean | contactsArgs
    preferences?: boolean | preferencesArgs
  }

  export type contacts_channelsInclude = {
    channels?: boolean | channelsArgs
    contacts?: boolean | contactsArgs
    preferences?: boolean | preferencesArgs
  }

  export type contacts_channelsGetPayload<
    S extends boolean | null | undefined | contacts_channelsArgs,
    U = keyof S
      > = S extends true
        ? contacts_channels
    : S extends undefined
    ? never
    : S extends contacts_channelsArgs | contacts_channelsFindManyArgs
    ?'include' extends U
    ? contacts_channels  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'channels'
        ? channelsGetPayload<S['include'][P]> :
        P extends 'contacts'
        ? contactsGetPayload<S['include'][P]> :
        P extends 'preferences'
        ? preferencesGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof contacts_channels ?contacts_channels [P]
  : 
          P extends 'channels'
        ? channelsGetPayload<S['select'][P]> :
        P extends 'contacts'
        ? contactsGetPayload<S['select'][P]> :
        P extends 'preferences'
        ? preferencesGetPayload<S['select'][P]> : never
  } 
    : contacts_channels
  : contacts_channels


  type contacts_channelsCountArgs = Merge<
    Omit<contacts_channelsFindManyArgs, 'select' | 'include'> & {
      select?: Contacts_channelsCountAggregateInputType | true
    }
  >

  export interface contacts_channelsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Contacts_channels that matches the filter.
     * @param {contacts_channelsFindUniqueArgs} args - Arguments to find a Contacts_channels
     * @example
     * // Get one Contacts_channels
     * const contacts_channels = await prisma.contacts_channels.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends contacts_channelsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, contacts_channelsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'contacts_channels'> extends True ? CheckSelect<T, Prisma__contacts_channelsClient<contacts_channels>, Prisma__contacts_channelsClient<contacts_channelsGetPayload<T>>> : CheckSelect<T, Prisma__contacts_channelsClient<contacts_channels | null >, Prisma__contacts_channelsClient<contacts_channelsGetPayload<T> | null >>

    /**
     * Find the first Contacts_channels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contacts_channelsFindFirstArgs} args - Arguments to find a Contacts_channels
     * @example
     * // Get one Contacts_channels
     * const contacts_channels = await prisma.contacts_channels.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends contacts_channelsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, contacts_channelsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'contacts_channels'> extends True ? CheckSelect<T, Prisma__contacts_channelsClient<contacts_channels>, Prisma__contacts_channelsClient<contacts_channelsGetPayload<T>>> : CheckSelect<T, Prisma__contacts_channelsClient<contacts_channels | null >, Prisma__contacts_channelsClient<contacts_channelsGetPayload<T> | null >>

    /**
     * Find zero or more Contacts_channels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contacts_channelsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts_channels
     * const contacts_channels = await prisma.contacts_channels.findMany()
     * 
     * // Get first 10 Contacts_channels
     * const contacts_channels = await prisma.contacts_channels.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contacts_channelsWithIdOnly = await prisma.contacts_channels.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends contacts_channelsFindManyArgs>(
      args?: SelectSubset<T, contacts_channelsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<contacts_channels>>, PrismaPromise<Array<contacts_channelsGetPayload<T>>>>

    /**
     * Create a Contacts_channels.
     * @param {contacts_channelsCreateArgs} args - Arguments to create a Contacts_channels.
     * @example
     * // Create one Contacts_channels
     * const Contacts_channels = await prisma.contacts_channels.create({
     *   data: {
     *     // ... data to create a Contacts_channels
     *   }
     * })
     * 
    **/
    create<T extends contacts_channelsCreateArgs>(
      args: SelectSubset<T, contacts_channelsCreateArgs>
    ): CheckSelect<T, Prisma__contacts_channelsClient<contacts_channels>, Prisma__contacts_channelsClient<contacts_channelsGetPayload<T>>>

    /**
     * Create many Contacts_channels.
     *     @param {contacts_channelsCreateManyArgs} args - Arguments to create many Contacts_channels.
     *     @example
     *     // Create many Contacts_channels
     *     const contacts_channels = await prisma.contacts_channels.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends contacts_channelsCreateManyArgs>(
      args?: SelectSubset<T, contacts_channelsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Contacts_channels.
     * @param {contacts_channelsDeleteArgs} args - Arguments to delete one Contacts_channels.
     * @example
     * // Delete one Contacts_channels
     * const Contacts_channels = await prisma.contacts_channels.delete({
     *   where: {
     *     // ... filter to delete one Contacts_channels
     *   }
     * })
     * 
    **/
    delete<T extends contacts_channelsDeleteArgs>(
      args: SelectSubset<T, contacts_channelsDeleteArgs>
    ): CheckSelect<T, Prisma__contacts_channelsClient<contacts_channels>, Prisma__contacts_channelsClient<contacts_channelsGetPayload<T>>>

    /**
     * Update one Contacts_channels.
     * @param {contacts_channelsUpdateArgs} args - Arguments to update one Contacts_channels.
     * @example
     * // Update one Contacts_channels
     * const contacts_channels = await prisma.contacts_channels.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends contacts_channelsUpdateArgs>(
      args: SelectSubset<T, contacts_channelsUpdateArgs>
    ): CheckSelect<T, Prisma__contacts_channelsClient<contacts_channels>, Prisma__contacts_channelsClient<contacts_channelsGetPayload<T>>>

    /**
     * Delete zero or more Contacts_channels.
     * @param {contacts_channelsDeleteManyArgs} args - Arguments to filter Contacts_channels to delete.
     * @example
     * // Delete a few Contacts_channels
     * const { count } = await prisma.contacts_channels.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends contacts_channelsDeleteManyArgs>(
      args?: SelectSubset<T, contacts_channelsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts_channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contacts_channelsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts_channels
     * const contacts_channels = await prisma.contacts_channels.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends contacts_channelsUpdateManyArgs>(
      args: SelectSubset<T, contacts_channelsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Contacts_channels.
     * @param {contacts_channelsUpsertArgs} args - Arguments to update or create a Contacts_channels.
     * @example
     * // Update or create a Contacts_channels
     * const contacts_channels = await prisma.contacts_channels.upsert({
     *   create: {
     *     // ... data to create a Contacts_channels
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contacts_channels we want to update
     *   }
     * })
    **/
    upsert<T extends contacts_channelsUpsertArgs>(
      args: SelectSubset<T, contacts_channelsUpsertArgs>
    ): CheckSelect<T, Prisma__contacts_channelsClient<contacts_channels>, Prisma__contacts_channelsClient<contacts_channelsGetPayload<T>>>

    /**
     * Count the number of Contacts_channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contacts_channelsCountArgs} args - Arguments to filter Contacts_channels to count.
     * @example
     * // Count the number of Contacts_channels
     * const count = await prisma.contacts_channels.count({
     *   where: {
     *     // ... the filter for the Contacts_channels we want to count
     *   }
     * })
    **/
    count<T extends contacts_channelsCountArgs>(
      args?: Subset<T, contacts_channelsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Contacts_channelsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contacts_channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contacts_channelsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Contacts_channelsAggregateArgs>(args: Subset<T, Contacts_channelsAggregateArgs>): PrismaPromise<GetContacts_channelsAggregateType<T>>

    /**
     * Group by Contacts_channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contacts_channelsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Contacts_channelsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Contacts_channelsGroupByArgs['orderBy'] }
        : { orderBy?: Contacts_channelsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Contacts_channelsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContacts_channelsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for contacts_channels.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__contacts_channelsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    channels<T extends channelsArgs = {}>(args?: Subset<T, channelsArgs>): CheckSelect<T, Prisma__channelsClient<channels | null >, Prisma__channelsClient<channelsGetPayload<T> | null >>;

    contacts<T extends contactsArgs = {}>(args?: Subset<T, contactsArgs>): CheckSelect<T, Prisma__contactsClient<contacts | null >, Prisma__contactsClient<contactsGetPayload<T> | null >>;

    preferences<T extends preferencesArgs = {}>(args?: Subset<T, preferencesArgs>): CheckSelect<T, Prisma__preferencesClient<preferences | null >, Prisma__preferencesClient<preferencesGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * contacts_channels findUnique
   */
  export type contacts_channelsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the contacts_channels
     * 
    **/
    select?: contacts_channelsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: contacts_channelsInclude | null
    /**
     * Throw an Error if a contacts_channels can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which contacts_channels to fetch.
     * 
    **/
    where: contacts_channelsWhereUniqueInput
  }


  /**
   * contacts_channels findFirst
   */
  export type contacts_channelsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the contacts_channels
     * 
    **/
    select?: contacts_channelsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: contacts_channelsInclude | null
    /**
     * Throw an Error if a contacts_channels can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which contacts_channels to fetch.
     * 
    **/
    where?: contacts_channelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts_channels to fetch.
     * 
    **/
    orderBy?: Enumerable<contacts_channelsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contacts_channels.
     * 
    **/
    cursor?: contacts_channelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts_channels from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts_channels.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contacts_channels.
     * 
    **/
    distinct?: Enumerable<Contacts_channelsScalarFieldEnum>
  }


  /**
   * contacts_channels findMany
   */
  export type contacts_channelsFindManyArgs = {
    /**
     * Select specific fields to fetch from the contacts_channels
     * 
    **/
    select?: contacts_channelsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: contacts_channelsInclude | null
    /**
     * Filter, which contacts_channels to fetch.
     * 
    **/
    where?: contacts_channelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts_channels to fetch.
     * 
    **/
    orderBy?: Enumerable<contacts_channelsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing contacts_channels.
     * 
    **/
    cursor?: contacts_channelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts_channels from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts_channels.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Contacts_channelsScalarFieldEnum>
  }


  /**
   * contacts_channels create
   */
  export type contacts_channelsCreateArgs = {
    /**
     * Select specific fields to fetch from the contacts_channels
     * 
    **/
    select?: contacts_channelsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: contacts_channelsInclude | null
    /**
     * The data needed to create a contacts_channels.
     * 
    **/
    data: XOR<contacts_channelsCreateInput, contacts_channelsUncheckedCreateInput>
  }


  /**
   * contacts_channels createMany
   */
  export type contacts_channelsCreateManyArgs = {
    data: Enumerable<contacts_channelsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * contacts_channels update
   */
  export type contacts_channelsUpdateArgs = {
    /**
     * Select specific fields to fetch from the contacts_channels
     * 
    **/
    select?: contacts_channelsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: contacts_channelsInclude | null
    /**
     * The data needed to update a contacts_channels.
     * 
    **/
    data: XOR<contacts_channelsUpdateInput, contacts_channelsUncheckedUpdateInput>
    /**
     * Choose, which contacts_channels to update.
     * 
    **/
    where: contacts_channelsWhereUniqueInput
  }


  /**
   * contacts_channels updateMany
   */
  export type contacts_channelsUpdateManyArgs = {
    data: XOR<contacts_channelsUpdateManyMutationInput, contacts_channelsUncheckedUpdateManyInput>
    where?: contacts_channelsWhereInput
  }


  /**
   * contacts_channels upsert
   */
  export type contacts_channelsUpsertArgs = {
    /**
     * Select specific fields to fetch from the contacts_channels
     * 
    **/
    select?: contacts_channelsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: contacts_channelsInclude | null
    /**
     * The filter to search for the contacts_channels to update in case it exists.
     * 
    **/
    where: contacts_channelsWhereUniqueInput
    /**
     * In case the contacts_channels found by the `where` argument doesn't exist, create a new contacts_channels with this data.
     * 
    **/
    create: XOR<contacts_channelsCreateInput, contacts_channelsUncheckedCreateInput>
    /**
     * In case the contacts_channels was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<contacts_channelsUpdateInput, contacts_channelsUncheckedUpdateInput>
  }


  /**
   * contacts_channels delete
   */
  export type contacts_channelsDeleteArgs = {
    /**
     * Select specific fields to fetch from the contacts_channels
     * 
    **/
    select?: contacts_channelsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: contacts_channelsInclude | null
    /**
     * Filter which contacts_channels to delete.
     * 
    **/
    where: contacts_channelsWhereUniqueInput
  }


  /**
   * contacts_channels deleteMany
   */
  export type contacts_channelsDeleteManyArgs = {
    where?: contacts_channelsWhereInput
  }


  /**
   * contacts_channels without action
   */
  export type contacts_channelsArgs = {
    /**
     * Select specific fields to fetch from the contacts_channels
     * 
    **/
    select?: contacts_channelsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: contacts_channelsInclude | null
  }



  /**
   * Model countries
   */


  export type AggregateCountries = {
    _count: CountriesCountAggregateOutputType | null
    _avg: CountriesAvgAggregateOutputType | null
    _sum: CountriesSumAggregateOutputType | null
    _min: CountriesMinAggregateOutputType | null
    _max: CountriesMaxAggregateOutputType | null
  }

  export type CountriesAvgAggregateOutputType = {
    id: number | null
    regions_id: number | null
  }

  export type CountriesSumAggregateOutputType = {
    id: number | null
    regions_id: number | null
  }

  export type CountriesMinAggregateOutputType = {
    id: number | null
    name: string | null
    regions_id: number | null
    isactive: boolean | null
  }

  export type CountriesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    regions_id: number | null
    isactive: boolean | null
  }

  export type CountriesCountAggregateOutputType = {
    id: number
    name: number
    regions_id: number
    isactive: number
    _all: number
  }


  export type CountriesAvgAggregateInputType = {
    id?: true
    regions_id?: true
  }

  export type CountriesSumAggregateInputType = {
    id?: true
    regions_id?: true
  }

  export type CountriesMinAggregateInputType = {
    id?: true
    name?: true
    regions_id?: true
    isactive?: true
  }

  export type CountriesMaxAggregateInputType = {
    id?: true
    name?: true
    regions_id?: true
    isactive?: true
  }

  export type CountriesCountAggregateInputType = {
    id?: true
    name?: true
    regions_id?: true
    isactive?: true
    _all?: true
  }

  export type CountriesAggregateArgs = {
    /**
     * Filter which countries to aggregate.
     * 
    **/
    where?: countriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of countries to fetch.
     * 
    **/
    orderBy?: Enumerable<countriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: countriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` countries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` countries.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned countries
    **/
    _count?: true | CountriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CountriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CountriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountriesMaxAggregateInputType
  }

  export type GetCountriesAggregateType<T extends CountriesAggregateArgs> = {
        [P in keyof T & keyof AggregateCountries]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountries[P]>
      : GetScalarType<T[P], AggregateCountries[P]>
  }


    
    
  export type CountriesGroupByArgs = {
    where?: countriesWhereInput
    orderBy?: Enumerable<countriesOrderByWithAggregationInput>
    by: Array<CountriesScalarFieldEnum>
    having?: countriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountriesCountAggregateInputType | true
    _avg?: CountriesAvgAggregateInputType
    _sum?: CountriesSumAggregateInputType
    _min?: CountriesMinAggregateInputType
    _max?: CountriesMaxAggregateInputType
  }


  export type CountriesGroupByOutputType = {
    id: number
    name: string
    regions_id: number
    isactive: boolean | null
    _count: CountriesCountAggregateOutputType | null
    _avg: CountriesAvgAggregateOutputType | null
    _sum: CountriesSumAggregateOutputType | null
    _min: CountriesMinAggregateOutputType | null
    _max: CountriesMaxAggregateOutputType | null
  }

  type GetCountriesGroupByPayload<T extends CountriesGroupByArgs> = Promise<
    Array<
      PickArray<CountriesGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof CountriesGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], CountriesGroupByOutputType[P]> 
            : GetScalarType<T[P], CountriesGroupByOutputType[P]>
        }
      > 
    >


  export type countriesSelect = {
    id?: boolean
    name?: boolean
    regions_id?: boolean
    isactive?: boolean
    regions?: boolean | regionsArgs
    cities?: boolean | citiesFindManyArgs
    _count?: boolean | CountriesCountOutputTypeArgs
  }

  export type countriesInclude = {
    regions?: boolean | regionsArgs
    cities?: boolean | citiesFindManyArgs
    _count?: boolean | CountriesCountOutputTypeArgs
  }

  export type countriesGetPayload<
    S extends boolean | null | undefined | countriesArgs,
    U = keyof S
      > = S extends true
        ? countries
    : S extends undefined
    ? never
    : S extends countriesArgs | countriesFindManyArgs
    ?'include' extends U
    ? countries  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'regions'
        ? regionsGetPayload<S['include'][P]> :
        P extends 'cities'
        ? Array < citiesGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? CountriesCountOutputTypeGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof countries ?countries [P]
  : 
          P extends 'regions'
        ? regionsGetPayload<S['select'][P]> :
        P extends 'cities'
        ? Array < citiesGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? CountriesCountOutputTypeGetPayload<S['select'][P]> | null : never
  } 
    : countries
  : countries


  type countriesCountArgs = Merge<
    Omit<countriesFindManyArgs, 'select' | 'include'> & {
      select?: CountriesCountAggregateInputType | true
    }
  >

  export interface countriesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Countries that matches the filter.
     * @param {countriesFindUniqueArgs} args - Arguments to find a Countries
     * @example
     * // Get one Countries
     * const countries = await prisma.countries.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends countriesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, countriesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'countries'> extends True ? CheckSelect<T, Prisma__countriesClient<countries>, Prisma__countriesClient<countriesGetPayload<T>>> : CheckSelect<T, Prisma__countriesClient<countries | null >, Prisma__countriesClient<countriesGetPayload<T> | null >>

    /**
     * Find the first Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countriesFindFirstArgs} args - Arguments to find a Countries
     * @example
     * // Get one Countries
     * const countries = await prisma.countries.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends countriesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, countriesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'countries'> extends True ? CheckSelect<T, Prisma__countriesClient<countries>, Prisma__countriesClient<countriesGetPayload<T>>> : CheckSelect<T, Prisma__countriesClient<countries | null >, Prisma__countriesClient<countriesGetPayload<T> | null >>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countriesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.countries.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.countries.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const countriesWithIdOnly = await prisma.countries.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends countriesFindManyArgs>(
      args?: SelectSubset<T, countriesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<countries>>, PrismaPromise<Array<countriesGetPayload<T>>>>

    /**
     * Create a Countries.
     * @param {countriesCreateArgs} args - Arguments to create a Countries.
     * @example
     * // Create one Countries
     * const Countries = await prisma.countries.create({
     *   data: {
     *     // ... data to create a Countries
     *   }
     * })
     * 
    **/
    create<T extends countriesCreateArgs>(
      args: SelectSubset<T, countriesCreateArgs>
    ): CheckSelect<T, Prisma__countriesClient<countries>, Prisma__countriesClient<countriesGetPayload<T>>>

    /**
     * Create many Countries.
     *     @param {countriesCreateManyArgs} args - Arguments to create many Countries.
     *     @example
     *     // Create many Countries
     *     const countries = await prisma.countries.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends countriesCreateManyArgs>(
      args?: SelectSubset<T, countriesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Countries.
     * @param {countriesDeleteArgs} args - Arguments to delete one Countries.
     * @example
     * // Delete one Countries
     * const Countries = await prisma.countries.delete({
     *   where: {
     *     // ... filter to delete one Countries
     *   }
     * })
     * 
    **/
    delete<T extends countriesDeleteArgs>(
      args: SelectSubset<T, countriesDeleteArgs>
    ): CheckSelect<T, Prisma__countriesClient<countries>, Prisma__countriesClient<countriesGetPayload<T>>>

    /**
     * Update one Countries.
     * @param {countriesUpdateArgs} args - Arguments to update one Countries.
     * @example
     * // Update one Countries
     * const countries = await prisma.countries.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends countriesUpdateArgs>(
      args: SelectSubset<T, countriesUpdateArgs>
    ): CheckSelect<T, Prisma__countriesClient<countries>, Prisma__countriesClient<countriesGetPayload<T>>>

    /**
     * Delete zero or more Countries.
     * @param {countriesDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.countries.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends countriesDeleteManyArgs>(
      args?: SelectSubset<T, countriesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const countries = await prisma.countries.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends countriesUpdateManyArgs>(
      args: SelectSubset<T, countriesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Countries.
     * @param {countriesUpsertArgs} args - Arguments to update or create a Countries.
     * @example
     * // Update or create a Countries
     * const countries = await prisma.countries.upsert({
     *   create: {
     *     // ... data to create a Countries
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Countries we want to update
     *   }
     * })
    **/
    upsert<T extends countriesUpsertArgs>(
      args: SelectSubset<T, countriesUpsertArgs>
    ): CheckSelect<T, Prisma__countriesClient<countries>, Prisma__countriesClient<countriesGetPayload<T>>>

    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countriesCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.countries.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends countriesCountArgs>(
      args?: Subset<T, countriesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountriesAggregateArgs>(args: Subset<T, CountriesAggregateArgs>): PrismaPromise<GetCountriesAggregateType<T>>

    /**
     * Group by Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountriesGroupByArgs['orderBy'] }
        : { orderBy?: CountriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountriesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for countries.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__countriesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    regions<T extends regionsArgs = {}>(args?: Subset<T, regionsArgs>): CheckSelect<T, Prisma__regionsClient<regions | null >, Prisma__regionsClient<regionsGetPayload<T> | null >>;

    cities<T extends citiesFindManyArgs = {}>(args?: Subset<T, citiesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<cities>>, PrismaPromise<Array<citiesGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * countries findUnique
   */
  export type countriesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the countries
     * 
    **/
    select?: countriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: countriesInclude | null
    /**
     * Throw an Error if a countries can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which countries to fetch.
     * 
    **/
    where: countriesWhereUniqueInput
  }


  /**
   * countries findFirst
   */
  export type countriesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the countries
     * 
    **/
    select?: countriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: countriesInclude | null
    /**
     * Throw an Error if a countries can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which countries to fetch.
     * 
    **/
    where?: countriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of countries to fetch.
     * 
    **/
    orderBy?: Enumerable<countriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for countries.
     * 
    **/
    cursor?: countriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` countries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` countries.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of countries.
     * 
    **/
    distinct?: Enumerable<CountriesScalarFieldEnum>
  }


  /**
   * countries findMany
   */
  export type countriesFindManyArgs = {
    /**
     * Select specific fields to fetch from the countries
     * 
    **/
    select?: countriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: countriesInclude | null
    /**
     * Filter, which countries to fetch.
     * 
    **/
    where?: countriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of countries to fetch.
     * 
    **/
    orderBy?: Enumerable<countriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing countries.
     * 
    **/
    cursor?: countriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` countries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` countries.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CountriesScalarFieldEnum>
  }


  /**
   * countries create
   */
  export type countriesCreateArgs = {
    /**
     * Select specific fields to fetch from the countries
     * 
    **/
    select?: countriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: countriesInclude | null
    /**
     * The data needed to create a countries.
     * 
    **/
    data: XOR<countriesCreateInput, countriesUncheckedCreateInput>
  }


  /**
   * countries createMany
   */
  export type countriesCreateManyArgs = {
    data: Enumerable<countriesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * countries update
   */
  export type countriesUpdateArgs = {
    /**
     * Select specific fields to fetch from the countries
     * 
    **/
    select?: countriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: countriesInclude | null
    /**
     * The data needed to update a countries.
     * 
    **/
    data: XOR<countriesUpdateInput, countriesUncheckedUpdateInput>
    /**
     * Choose, which countries to update.
     * 
    **/
    where: countriesWhereUniqueInput
  }


  /**
   * countries updateMany
   */
  export type countriesUpdateManyArgs = {
    data: XOR<countriesUpdateManyMutationInput, countriesUncheckedUpdateManyInput>
    where?: countriesWhereInput
  }


  /**
   * countries upsert
   */
  export type countriesUpsertArgs = {
    /**
     * Select specific fields to fetch from the countries
     * 
    **/
    select?: countriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: countriesInclude | null
    /**
     * The filter to search for the countries to update in case it exists.
     * 
    **/
    where: countriesWhereUniqueInput
    /**
     * In case the countries found by the `where` argument doesn't exist, create a new countries with this data.
     * 
    **/
    create: XOR<countriesCreateInput, countriesUncheckedCreateInput>
    /**
     * In case the countries was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<countriesUpdateInput, countriesUncheckedUpdateInput>
  }


  /**
   * countries delete
   */
  export type countriesDeleteArgs = {
    /**
     * Select specific fields to fetch from the countries
     * 
    **/
    select?: countriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: countriesInclude | null
    /**
     * Filter which countries to delete.
     * 
    **/
    where: countriesWhereUniqueInput
  }


  /**
   * countries deleteMany
   */
  export type countriesDeleteManyArgs = {
    where?: countriesWhereInput
  }


  /**
   * countries without action
   */
  export type countriesArgs = {
    /**
     * Select specific fields to fetch from the countries
     * 
    **/
    select?: countriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: countriesInclude | null
  }



  /**
   * Model preferences
   */


  export type AggregatePreferences = {
    _count: PreferencesCountAggregateOutputType | null
    _avg: PreferencesAvgAggregateOutputType | null
    _sum: PreferencesSumAggregateOutputType | null
    _min: PreferencesMinAggregateOutputType | null
    _max: PreferencesMaxAggregateOutputType | null
  }

  export type PreferencesAvgAggregateOutputType = {
    id: number | null
  }

  export type PreferencesSumAggregateOutputType = {
    id: number | null
  }

  export type PreferencesMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type PreferencesMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type PreferencesCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type PreferencesAvgAggregateInputType = {
    id?: true
  }

  export type PreferencesSumAggregateInputType = {
    id?: true
  }

  export type PreferencesMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type PreferencesMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type PreferencesCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type PreferencesAggregateArgs = {
    /**
     * Filter which preferences to aggregate.
     * 
    **/
    where?: preferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of preferences to fetch.
     * 
    **/
    orderBy?: Enumerable<preferencesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: preferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` preferences from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` preferences.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned preferences
    **/
    _count?: true | PreferencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PreferencesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PreferencesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PreferencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PreferencesMaxAggregateInputType
  }

  export type GetPreferencesAggregateType<T extends PreferencesAggregateArgs> = {
        [P in keyof T & keyof AggregatePreferences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePreferences[P]>
      : GetScalarType<T[P], AggregatePreferences[P]>
  }


    
    
  export type PreferencesGroupByArgs = {
    where?: preferencesWhereInput
    orderBy?: Enumerable<preferencesOrderByWithAggregationInput>
    by: Array<PreferencesScalarFieldEnum>
    having?: preferencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PreferencesCountAggregateInputType | true
    _avg?: PreferencesAvgAggregateInputType
    _sum?: PreferencesSumAggregateInputType
    _min?: PreferencesMinAggregateInputType
    _max?: PreferencesMaxAggregateInputType
  }


  export type PreferencesGroupByOutputType = {
    id: number
    name: string
    _count: PreferencesCountAggregateOutputType | null
    _avg: PreferencesAvgAggregateOutputType | null
    _sum: PreferencesSumAggregateOutputType | null
    _min: PreferencesMinAggregateOutputType | null
    _max: PreferencesMaxAggregateOutputType | null
  }

  type GetPreferencesGroupByPayload<T extends PreferencesGroupByArgs> = Promise<
    Array<
      PickArray<PreferencesGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof PreferencesGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], PreferencesGroupByOutputType[P]> 
            : GetScalarType<T[P], PreferencesGroupByOutputType[P]>
        }
      > 
    >


  export type preferencesSelect = {
    id?: boolean
    name?: boolean
    contacts_channels?: boolean | contacts_channelsFindManyArgs
    _count?: boolean | PreferencesCountOutputTypeArgs
  }

  export type preferencesInclude = {
    contacts_channels?: boolean | contacts_channelsFindManyArgs
    _count?: boolean | PreferencesCountOutputTypeArgs
  }

  export type preferencesGetPayload<
    S extends boolean | null | undefined | preferencesArgs,
    U = keyof S
      > = S extends true
        ? preferences
    : S extends undefined
    ? never
    : S extends preferencesArgs | preferencesFindManyArgs
    ?'include' extends U
    ? preferences  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'contacts_channels'
        ? Array < contacts_channelsGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? PreferencesCountOutputTypeGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof preferences ?preferences [P]
  : 
          P extends 'contacts_channels'
        ? Array < contacts_channelsGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? PreferencesCountOutputTypeGetPayload<S['select'][P]> | null : never
  } 
    : preferences
  : preferences


  type preferencesCountArgs = Merge<
    Omit<preferencesFindManyArgs, 'select' | 'include'> & {
      select?: PreferencesCountAggregateInputType | true
    }
  >

  export interface preferencesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Preferences that matches the filter.
     * @param {preferencesFindUniqueArgs} args - Arguments to find a Preferences
     * @example
     * // Get one Preferences
     * const preferences = await prisma.preferences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends preferencesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, preferencesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'preferences'> extends True ? CheckSelect<T, Prisma__preferencesClient<preferences>, Prisma__preferencesClient<preferencesGetPayload<T>>> : CheckSelect<T, Prisma__preferencesClient<preferences | null >, Prisma__preferencesClient<preferencesGetPayload<T> | null >>

    /**
     * Find the first Preferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preferencesFindFirstArgs} args - Arguments to find a Preferences
     * @example
     * // Get one Preferences
     * const preferences = await prisma.preferences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends preferencesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, preferencesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'preferences'> extends True ? CheckSelect<T, Prisma__preferencesClient<preferences>, Prisma__preferencesClient<preferencesGetPayload<T>>> : CheckSelect<T, Prisma__preferencesClient<preferences | null >, Prisma__preferencesClient<preferencesGetPayload<T> | null >>

    /**
     * Find zero or more Preferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preferencesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Preferences
     * const preferences = await prisma.preferences.findMany()
     * 
     * // Get first 10 Preferences
     * const preferences = await prisma.preferences.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const preferencesWithIdOnly = await prisma.preferences.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends preferencesFindManyArgs>(
      args?: SelectSubset<T, preferencesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<preferences>>, PrismaPromise<Array<preferencesGetPayload<T>>>>

    /**
     * Create a Preferences.
     * @param {preferencesCreateArgs} args - Arguments to create a Preferences.
     * @example
     * // Create one Preferences
     * const Preferences = await prisma.preferences.create({
     *   data: {
     *     // ... data to create a Preferences
     *   }
     * })
     * 
    **/
    create<T extends preferencesCreateArgs>(
      args: SelectSubset<T, preferencesCreateArgs>
    ): CheckSelect<T, Prisma__preferencesClient<preferences>, Prisma__preferencesClient<preferencesGetPayload<T>>>

    /**
     * Create many Preferences.
     *     @param {preferencesCreateManyArgs} args - Arguments to create many Preferences.
     *     @example
     *     // Create many Preferences
     *     const preferences = await prisma.preferences.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends preferencesCreateManyArgs>(
      args?: SelectSubset<T, preferencesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Preferences.
     * @param {preferencesDeleteArgs} args - Arguments to delete one Preferences.
     * @example
     * // Delete one Preferences
     * const Preferences = await prisma.preferences.delete({
     *   where: {
     *     // ... filter to delete one Preferences
     *   }
     * })
     * 
    **/
    delete<T extends preferencesDeleteArgs>(
      args: SelectSubset<T, preferencesDeleteArgs>
    ): CheckSelect<T, Prisma__preferencesClient<preferences>, Prisma__preferencesClient<preferencesGetPayload<T>>>

    /**
     * Update one Preferences.
     * @param {preferencesUpdateArgs} args - Arguments to update one Preferences.
     * @example
     * // Update one Preferences
     * const preferences = await prisma.preferences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends preferencesUpdateArgs>(
      args: SelectSubset<T, preferencesUpdateArgs>
    ): CheckSelect<T, Prisma__preferencesClient<preferences>, Prisma__preferencesClient<preferencesGetPayload<T>>>

    /**
     * Delete zero or more Preferences.
     * @param {preferencesDeleteManyArgs} args - Arguments to filter Preferences to delete.
     * @example
     * // Delete a few Preferences
     * const { count } = await prisma.preferences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends preferencesDeleteManyArgs>(
      args?: SelectSubset<T, preferencesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Preferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preferencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Preferences
     * const preferences = await prisma.preferences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends preferencesUpdateManyArgs>(
      args: SelectSubset<T, preferencesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Preferences.
     * @param {preferencesUpsertArgs} args - Arguments to update or create a Preferences.
     * @example
     * // Update or create a Preferences
     * const preferences = await prisma.preferences.upsert({
     *   create: {
     *     // ... data to create a Preferences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Preferences we want to update
     *   }
     * })
    **/
    upsert<T extends preferencesUpsertArgs>(
      args: SelectSubset<T, preferencesUpsertArgs>
    ): CheckSelect<T, Prisma__preferencesClient<preferences>, Prisma__preferencesClient<preferencesGetPayload<T>>>

    /**
     * Count the number of Preferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preferencesCountArgs} args - Arguments to filter Preferences to count.
     * @example
     * // Count the number of Preferences
     * const count = await prisma.preferences.count({
     *   where: {
     *     // ... the filter for the Preferences we want to count
     *   }
     * })
    **/
    count<T extends preferencesCountArgs>(
      args?: Subset<T, preferencesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PreferencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Preferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PreferencesAggregateArgs>(args: Subset<T, PreferencesAggregateArgs>): PrismaPromise<GetPreferencesAggregateType<T>>

    /**
     * Group by Preferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PreferencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PreferencesGroupByArgs['orderBy'] }
        : { orderBy?: PreferencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PreferencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPreferencesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for preferences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__preferencesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    contacts_channels<T extends contacts_channelsFindManyArgs = {}>(args?: Subset<T, contacts_channelsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<contacts_channels>>, PrismaPromise<Array<contacts_channelsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * preferences findUnique
   */
  export type preferencesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the preferences
     * 
    **/
    select?: preferencesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: preferencesInclude | null
    /**
     * Throw an Error if a preferences can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which preferences to fetch.
     * 
    **/
    where: preferencesWhereUniqueInput
  }


  /**
   * preferences findFirst
   */
  export type preferencesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the preferences
     * 
    **/
    select?: preferencesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: preferencesInclude | null
    /**
     * Throw an Error if a preferences can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which preferences to fetch.
     * 
    **/
    where?: preferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of preferences to fetch.
     * 
    **/
    orderBy?: Enumerable<preferencesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for preferences.
     * 
    **/
    cursor?: preferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` preferences from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` preferences.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of preferences.
     * 
    **/
    distinct?: Enumerable<PreferencesScalarFieldEnum>
  }


  /**
   * preferences findMany
   */
  export type preferencesFindManyArgs = {
    /**
     * Select specific fields to fetch from the preferences
     * 
    **/
    select?: preferencesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: preferencesInclude | null
    /**
     * Filter, which preferences to fetch.
     * 
    **/
    where?: preferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of preferences to fetch.
     * 
    **/
    orderBy?: Enumerable<preferencesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing preferences.
     * 
    **/
    cursor?: preferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` preferences from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` preferences.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PreferencesScalarFieldEnum>
  }


  /**
   * preferences create
   */
  export type preferencesCreateArgs = {
    /**
     * Select specific fields to fetch from the preferences
     * 
    **/
    select?: preferencesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: preferencesInclude | null
    /**
     * The data needed to create a preferences.
     * 
    **/
    data: XOR<preferencesCreateInput, preferencesUncheckedCreateInput>
  }


  /**
   * preferences createMany
   */
  export type preferencesCreateManyArgs = {
    data: Enumerable<preferencesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * preferences update
   */
  export type preferencesUpdateArgs = {
    /**
     * Select specific fields to fetch from the preferences
     * 
    **/
    select?: preferencesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: preferencesInclude | null
    /**
     * The data needed to update a preferences.
     * 
    **/
    data: XOR<preferencesUpdateInput, preferencesUncheckedUpdateInput>
    /**
     * Choose, which preferences to update.
     * 
    **/
    where: preferencesWhereUniqueInput
  }


  /**
   * preferences updateMany
   */
  export type preferencesUpdateManyArgs = {
    data: XOR<preferencesUpdateManyMutationInput, preferencesUncheckedUpdateManyInput>
    where?: preferencesWhereInput
  }


  /**
   * preferences upsert
   */
  export type preferencesUpsertArgs = {
    /**
     * Select specific fields to fetch from the preferences
     * 
    **/
    select?: preferencesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: preferencesInclude | null
    /**
     * The filter to search for the preferences to update in case it exists.
     * 
    **/
    where: preferencesWhereUniqueInput
    /**
     * In case the preferences found by the `where` argument doesn't exist, create a new preferences with this data.
     * 
    **/
    create: XOR<preferencesCreateInput, preferencesUncheckedCreateInput>
    /**
     * In case the preferences was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<preferencesUpdateInput, preferencesUncheckedUpdateInput>
  }


  /**
   * preferences delete
   */
  export type preferencesDeleteArgs = {
    /**
     * Select specific fields to fetch from the preferences
     * 
    **/
    select?: preferencesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: preferencesInclude | null
    /**
     * Filter which preferences to delete.
     * 
    **/
    where: preferencesWhereUniqueInput
  }


  /**
   * preferences deleteMany
   */
  export type preferencesDeleteManyArgs = {
    where?: preferencesWhereInput
  }


  /**
   * preferences without action
   */
  export type preferencesArgs = {
    /**
     * Select specific fields to fetch from the preferences
     * 
    **/
    select?: preferencesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: preferencesInclude | null
  }



  /**
   * Model regions
   */


  export type AggregateRegions = {
    _count: RegionsCountAggregateOutputType | null
    _avg: RegionsAvgAggregateOutputType | null
    _sum: RegionsSumAggregateOutputType | null
    _min: RegionsMinAggregateOutputType | null
    _max: RegionsMaxAggregateOutputType | null
  }

  export type RegionsAvgAggregateOutputType = {
    id: number | null
  }

  export type RegionsSumAggregateOutputType = {
    id: number | null
  }

  export type RegionsMinAggregateOutputType = {
    id: number | null
    name: string | null
    isactive: boolean | null
  }

  export type RegionsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    isactive: boolean | null
  }

  export type RegionsCountAggregateOutputType = {
    id: number
    name: number
    isactive: number
    _all: number
  }


  export type RegionsAvgAggregateInputType = {
    id?: true
  }

  export type RegionsSumAggregateInputType = {
    id?: true
  }

  export type RegionsMinAggregateInputType = {
    id?: true
    name?: true
    isactive?: true
  }

  export type RegionsMaxAggregateInputType = {
    id?: true
    name?: true
    isactive?: true
  }

  export type RegionsCountAggregateInputType = {
    id?: true
    name?: true
    isactive?: true
    _all?: true
  }

  export type RegionsAggregateArgs = {
    /**
     * Filter which regions to aggregate.
     * 
    **/
    where?: regionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of regions to fetch.
     * 
    **/
    orderBy?: Enumerable<regionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: regionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` regions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` regions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned regions
    **/
    _count?: true | RegionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RegionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RegionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegionsMaxAggregateInputType
  }

  export type GetRegionsAggregateType<T extends RegionsAggregateArgs> = {
        [P in keyof T & keyof AggregateRegions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegions[P]>
      : GetScalarType<T[P], AggregateRegions[P]>
  }


    
    
  export type RegionsGroupByArgs = {
    where?: regionsWhereInput
    orderBy?: Enumerable<regionsOrderByWithAggregationInput>
    by: Array<RegionsScalarFieldEnum>
    having?: regionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegionsCountAggregateInputType | true
    _avg?: RegionsAvgAggregateInputType
    _sum?: RegionsSumAggregateInputType
    _min?: RegionsMinAggregateInputType
    _max?: RegionsMaxAggregateInputType
  }


  export type RegionsGroupByOutputType = {
    id: number
    name: string
    isactive: boolean | null
    _count: RegionsCountAggregateOutputType | null
    _avg: RegionsAvgAggregateOutputType | null
    _sum: RegionsSumAggregateOutputType | null
    _min: RegionsMinAggregateOutputType | null
    _max: RegionsMaxAggregateOutputType | null
  }

  type GetRegionsGroupByPayload<T extends RegionsGroupByArgs> = Promise<
    Array<
      PickArray<RegionsGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof RegionsGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], RegionsGroupByOutputType[P]> 
            : GetScalarType<T[P], RegionsGroupByOutputType[P]>
        }
      > 
    >


  export type regionsSelect = {
    id?: boolean
    name?: boolean
    isactive?: boolean
    countries?: boolean | countriesFindManyArgs
    _count?: boolean | RegionsCountOutputTypeArgs
  }

  export type regionsInclude = {
    countries?: boolean | countriesFindManyArgs
    _count?: boolean | RegionsCountOutputTypeArgs
  }

  export type regionsGetPayload<
    S extends boolean | null | undefined | regionsArgs,
    U = keyof S
      > = S extends true
        ? regions
    : S extends undefined
    ? never
    : S extends regionsArgs | regionsFindManyArgs
    ?'include' extends U
    ? regions  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'countries'
        ? Array < countriesGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? RegionsCountOutputTypeGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof regions ?regions [P]
  : 
          P extends 'countries'
        ? Array < countriesGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? RegionsCountOutputTypeGetPayload<S['select'][P]> | null : never
  } 
    : regions
  : regions


  type regionsCountArgs = Merge<
    Omit<regionsFindManyArgs, 'select' | 'include'> & {
      select?: RegionsCountAggregateInputType | true
    }
  >

  export interface regionsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Regions that matches the filter.
     * @param {regionsFindUniqueArgs} args - Arguments to find a Regions
     * @example
     * // Get one Regions
     * const regions = await prisma.regions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends regionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, regionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'regions'> extends True ? CheckSelect<T, Prisma__regionsClient<regions>, Prisma__regionsClient<regionsGetPayload<T>>> : CheckSelect<T, Prisma__regionsClient<regions | null >, Prisma__regionsClient<regionsGetPayload<T> | null >>

    /**
     * Find the first Regions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regionsFindFirstArgs} args - Arguments to find a Regions
     * @example
     * // Get one Regions
     * const regions = await prisma.regions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends regionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, regionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'regions'> extends True ? CheckSelect<T, Prisma__regionsClient<regions>, Prisma__regionsClient<regionsGetPayload<T>>> : CheckSelect<T, Prisma__regionsClient<regions | null >, Prisma__regionsClient<regionsGetPayload<T> | null >>

    /**
     * Find zero or more Regions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Regions
     * const regions = await prisma.regions.findMany()
     * 
     * // Get first 10 Regions
     * const regions = await prisma.regions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const regionsWithIdOnly = await prisma.regions.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends regionsFindManyArgs>(
      args?: SelectSubset<T, regionsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<regions>>, PrismaPromise<Array<regionsGetPayload<T>>>>

    /**
     * Create a Regions.
     * @param {regionsCreateArgs} args - Arguments to create a Regions.
     * @example
     * // Create one Regions
     * const Regions = await prisma.regions.create({
     *   data: {
     *     // ... data to create a Regions
     *   }
     * })
     * 
    **/
    create<T extends regionsCreateArgs>(
      args: SelectSubset<T, regionsCreateArgs>
    ): CheckSelect<T, Prisma__regionsClient<regions>, Prisma__regionsClient<regionsGetPayload<T>>>

    /**
     * Create many Regions.
     *     @param {regionsCreateManyArgs} args - Arguments to create many Regions.
     *     @example
     *     // Create many Regions
     *     const regions = await prisma.regions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends regionsCreateManyArgs>(
      args?: SelectSubset<T, regionsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Regions.
     * @param {regionsDeleteArgs} args - Arguments to delete one Regions.
     * @example
     * // Delete one Regions
     * const Regions = await prisma.regions.delete({
     *   where: {
     *     // ... filter to delete one Regions
     *   }
     * })
     * 
    **/
    delete<T extends regionsDeleteArgs>(
      args: SelectSubset<T, regionsDeleteArgs>
    ): CheckSelect<T, Prisma__regionsClient<regions>, Prisma__regionsClient<regionsGetPayload<T>>>

    /**
     * Update one Regions.
     * @param {regionsUpdateArgs} args - Arguments to update one Regions.
     * @example
     * // Update one Regions
     * const regions = await prisma.regions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends regionsUpdateArgs>(
      args: SelectSubset<T, regionsUpdateArgs>
    ): CheckSelect<T, Prisma__regionsClient<regions>, Prisma__regionsClient<regionsGetPayload<T>>>

    /**
     * Delete zero or more Regions.
     * @param {regionsDeleteManyArgs} args - Arguments to filter Regions to delete.
     * @example
     * // Delete a few Regions
     * const { count } = await prisma.regions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends regionsDeleteManyArgs>(
      args?: SelectSubset<T, regionsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Regions
     * const regions = await prisma.regions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends regionsUpdateManyArgs>(
      args: SelectSubset<T, regionsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Regions.
     * @param {regionsUpsertArgs} args - Arguments to update or create a Regions.
     * @example
     * // Update or create a Regions
     * const regions = await prisma.regions.upsert({
     *   create: {
     *     // ... data to create a Regions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Regions we want to update
     *   }
     * })
    **/
    upsert<T extends regionsUpsertArgs>(
      args: SelectSubset<T, regionsUpsertArgs>
    ): CheckSelect<T, Prisma__regionsClient<regions>, Prisma__regionsClient<regionsGetPayload<T>>>

    /**
     * Count the number of Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regionsCountArgs} args - Arguments to filter Regions to count.
     * @example
     * // Count the number of Regions
     * const count = await prisma.regions.count({
     *   where: {
     *     // ... the filter for the Regions we want to count
     *   }
     * })
    **/
    count<T extends regionsCountArgs>(
      args?: Subset<T, regionsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegionsAggregateArgs>(args: Subset<T, RegionsAggregateArgs>): PrismaPromise<GetRegionsAggregateType<T>>

    /**
     * Group by Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegionsGroupByArgs['orderBy'] }
        : { orderBy?: RegionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegionsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for regions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__regionsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    countries<T extends countriesFindManyArgs = {}>(args?: Subset<T, countriesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<countries>>, PrismaPromise<Array<countriesGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * regions findUnique
   */
  export type regionsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the regions
     * 
    **/
    select?: regionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: regionsInclude | null
    /**
     * Throw an Error if a regions can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which regions to fetch.
     * 
    **/
    where: regionsWhereUniqueInput
  }


  /**
   * regions findFirst
   */
  export type regionsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the regions
     * 
    **/
    select?: regionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: regionsInclude | null
    /**
     * Throw an Error if a regions can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which regions to fetch.
     * 
    **/
    where?: regionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of regions to fetch.
     * 
    **/
    orderBy?: Enumerable<regionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for regions.
     * 
    **/
    cursor?: regionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` regions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` regions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of regions.
     * 
    **/
    distinct?: Enumerable<RegionsScalarFieldEnum>
  }


  /**
   * regions findMany
   */
  export type regionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the regions
     * 
    **/
    select?: regionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: regionsInclude | null
    /**
     * Filter, which regions to fetch.
     * 
    **/
    where?: regionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of regions to fetch.
     * 
    **/
    orderBy?: Enumerable<regionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing regions.
     * 
    **/
    cursor?: regionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` regions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` regions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RegionsScalarFieldEnum>
  }


  /**
   * regions create
   */
  export type regionsCreateArgs = {
    /**
     * Select specific fields to fetch from the regions
     * 
    **/
    select?: regionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: regionsInclude | null
    /**
     * The data needed to create a regions.
     * 
    **/
    data: XOR<regionsCreateInput, regionsUncheckedCreateInput>
  }


  /**
   * regions createMany
   */
  export type regionsCreateManyArgs = {
    data: Enumerable<regionsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * regions update
   */
  export type regionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the regions
     * 
    **/
    select?: regionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: regionsInclude | null
    /**
     * The data needed to update a regions.
     * 
    **/
    data: XOR<regionsUpdateInput, regionsUncheckedUpdateInput>
    /**
     * Choose, which regions to update.
     * 
    **/
    where: regionsWhereUniqueInput
  }


  /**
   * regions updateMany
   */
  export type regionsUpdateManyArgs = {
    data: XOR<regionsUpdateManyMutationInput, regionsUncheckedUpdateManyInput>
    where?: regionsWhereInput
  }


  /**
   * regions upsert
   */
  export type regionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the regions
     * 
    **/
    select?: regionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: regionsInclude | null
    /**
     * The filter to search for the regions to update in case it exists.
     * 
    **/
    where: regionsWhereUniqueInput
    /**
     * In case the regions found by the `where` argument doesn't exist, create a new regions with this data.
     * 
    **/
    create: XOR<regionsCreateInput, regionsUncheckedCreateInput>
    /**
     * In case the regions was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<regionsUpdateInput, regionsUncheckedUpdateInput>
  }


  /**
   * regions delete
   */
  export type regionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the regions
     * 
    **/
    select?: regionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: regionsInclude | null
    /**
     * Filter which regions to delete.
     * 
    **/
    where: regionsWhereUniqueInput
  }


  /**
   * regions deleteMany
   */
  export type regionsDeleteManyArgs = {
    where?: regionsWhereInput
  }


  /**
   * regions without action
   */
  export type regionsArgs = {
    /**
     * Select specific fields to fetch from the regions
     * 
    **/
    select?: regionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: regionsInclude | null
  }



  /**
   * Model users
   */


  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: number | null
    username: string | null
    lastname: string | null
    email: string | null
    password: string | null
    create_time: Date | null
    isadmin: boolean | null
    isactive: boolean | null
  }

  export type UsersMaxAggregateOutputType = {
    id: number | null
    username: string | null
    lastname: string | null
    email: string | null
    password: string | null
    create_time: Date | null
    isadmin: boolean | null
    isactive: boolean | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    username: number
    lastname: number
    email: number
    password: number
    create_time: number
    isadmin: number
    isactive: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    username?: true
    lastname?: true
    email?: true
    password?: true
    create_time?: true
    isadmin?: true
    isactive?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    username?: true
    lastname?: true
    email?: true
    password?: true
    create_time?: true
    isadmin?: true
    isactive?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    username?: true
    lastname?: true
    email?: true
    password?: true
    create_time?: true
    isadmin?: true
    isactive?: true
    _all?: true
  }

  export type UsersAggregateArgs = {
    /**
     * Filter which users to aggregate.
     * 
    **/
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     * 
    **/
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }


    
    
  export type UsersGroupByArgs = {
    where?: usersWhereInput
    orderBy?: Enumerable<usersOrderByWithAggregationInput>
    by: Array<UsersScalarFieldEnum>
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }


  export type UsersGroupByOutputType = {
    id: number
    username: string
    lastname: string
    email: string
    password: string
    create_time: Date | null
    isadmin: boolean | null
    isactive: boolean | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = Promise<
    Array<
      PickArray<UsersGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], UsersGroupByOutputType[P]> 
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      > 
    >


  export type usersSelect = {
    id?: boolean
    username?: boolean
    lastname?: boolean
    email?: boolean
    password?: boolean
    create_time?: boolean
    isadmin?: boolean
    isactive?: boolean
    contacts?: boolean | contactsFindManyArgs
    _count?: boolean | UsersCountOutputTypeArgs
  }

  export type usersInclude = {
    contacts?: boolean | contactsFindManyArgs
    _count?: boolean | UsersCountOutputTypeArgs
  }

  export type usersGetPayload<
    S extends boolean | null | undefined | usersArgs,
    U = keyof S
      > = S extends true
        ? users
    : S extends undefined
    ? never
    : S extends usersArgs | usersFindManyArgs
    ?'include' extends U
    ? users  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'contacts'
        ? Array < contactsGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? UsersCountOutputTypeGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof users ?users [P]
  : 
          P extends 'contacts'
        ? Array < contactsGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? UsersCountOutputTypeGetPayload<S['select'][P]> | null : never
  } 
    : users
  : users


  type usersCountArgs = Merge<
    Omit<usersFindManyArgs, 'select' | 'include'> & {
      select?: UsersCountAggregateInputType | true
    }
  >

  export interface usersDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends usersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, usersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'users'> extends True ? CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>> : CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends usersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, usersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'users'> extends True ? CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>> : CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends usersFindManyArgs>(
      args?: SelectSubset<T, usersFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<users>>, PrismaPromise<Array<usersGetPayload<T>>>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
    **/
    create<T extends usersCreateArgs>(
      args: SelectSubset<T, usersCreateArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {usersCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const users = await prisma.users.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends usersCreateManyArgs>(
      args?: SelectSubset<T, usersCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
    **/
    delete<T extends usersDeleteArgs>(
      args: SelectSubset<T, usersDeleteArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends usersUpdateArgs>(
      args: SelectSubset<T, usersUpdateArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends usersDeleteManyArgs>(
      args?: SelectSubset<T, usersDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends usersUpdateManyArgs>(
      args: SelectSubset<T, usersUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
    **/
    upsert<T extends usersUpsertArgs>(
      args: SelectSubset<T, usersUpsertArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__usersClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    contacts<T extends contactsFindManyArgs = {}>(args?: Subset<T, contactsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<contacts>>, PrismaPromise<Array<contactsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * users findUnique
   */
  export type usersFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * Throw an Error if a users can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which users to fetch.
     * 
    **/
    where: usersWhereUniqueInput
  }


  /**
   * users findFirst
   */
  export type usersFindFirstArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * Throw an Error if a users can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which users to fetch.
     * 
    **/
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     * 
    **/
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     * 
    **/
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     * 
    **/
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * users findMany
   */
  export type usersFindManyArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * Filter, which users to fetch.
     * 
    **/
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     * 
    **/
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     * 
    **/
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * users create
   */
  export type usersCreateArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * The data needed to create a users.
     * 
    **/
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }


  /**
   * users createMany
   */
  export type usersCreateManyArgs = {
    data: Enumerable<usersCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * users update
   */
  export type usersUpdateArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * The data needed to update a users.
     * 
    **/
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     * 
    **/
    where: usersWhereUniqueInput
  }


  /**
   * users updateMany
   */
  export type usersUpdateManyArgs = {
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    where?: usersWhereInput
  }


  /**
   * users upsert
   */
  export type usersUpsertArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * The filter to search for the users to update in case it exists.
     * 
    **/
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     * 
    **/
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }


  /**
   * users delete
   */
  export type usersDeleteArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * Filter which users to delete.
     * 
    **/
    where: usersWhereUniqueInput
  }


  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs = {
    where?: usersWhereInput
  }


  /**
   * users without action
   */
  export type usersArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const ChannelsScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type ChannelsScalarFieldEnum = (typeof ChannelsScalarFieldEnum)[keyof typeof ChannelsScalarFieldEnum]


  export const CitiesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    countries_id: 'countries_id',
    isactive: 'isactive'
  };

  export type CitiesScalarFieldEnum = (typeof CitiesScalarFieldEnum)[keyof typeof CitiesScalarFieldEnum]


  export const CompaniesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    email: 'email',
    phone: 'phone',
    cities_id: 'cities_id',
    isactive: 'isactive'
  };

  export type CompaniesScalarFieldEnum = (typeof CompaniesScalarFieldEnum)[keyof typeof CompaniesScalarFieldEnum]


  export const ContactsScalarFieldEnum: {
    id: 'id',
    username: 'username',
    lastname: 'lastname',
    email: 'email',
    job_tittle: 'job_tittle',
    create_time: 'create_time',
    address: 'address',
    interest: 'interest',
    imgUrl: 'imgUrl',
    users_id: 'users_id',
    companies_id: 'companies_id',
    cities_id: 'cities_id',
    isactive: 'isactive'
  };

  export type ContactsScalarFieldEnum = (typeof ContactsScalarFieldEnum)[keyof typeof ContactsScalarFieldEnum]


  export const Contacts_channelsScalarFieldEnum: {
    id: 'id',
    acount: 'acount',
    channels_id: 'channels_id',
    preferences_id: 'preferences_id',
    contacts_id: 'contacts_id'
  };

  export type Contacts_channelsScalarFieldEnum = (typeof Contacts_channelsScalarFieldEnum)[keyof typeof Contacts_channelsScalarFieldEnum]


  export const CountriesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    regions_id: 'regions_id',
    isactive: 'isactive'
  };

  export type CountriesScalarFieldEnum = (typeof CountriesScalarFieldEnum)[keyof typeof CountriesScalarFieldEnum]


  export const PreferencesScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type PreferencesScalarFieldEnum = (typeof PreferencesScalarFieldEnum)[keyof typeof PreferencesScalarFieldEnum]


  export const RegionsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    isactive: 'isactive'
  };

  export type RegionsScalarFieldEnum = (typeof RegionsScalarFieldEnum)[keyof typeof RegionsScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    username: 'username',
    lastname: 'lastname',
    email: 'email',
    password: 'password',
    create_time: 'create_time',
    isadmin: 'isadmin',
    isactive: 'isactive'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Deep Input Types
   */


  export type channelsWhereInput = {
    AND?: Enumerable<channelsWhereInput>
    OR?: Enumerable<channelsWhereInput>
    NOT?: Enumerable<channelsWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    contacts_channels?: Contacts_channelsListRelationFilter
  }

  export type channelsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    contacts_channels?: contacts_channelsOrderByRelationAggregateInput
  }

  export type channelsWhereUniqueInput = {
    id?: number
  }

  export type channelsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: channelsCountOrderByAggregateInput
    _avg?: channelsAvgOrderByAggregateInput
    _max?: channelsMaxOrderByAggregateInput
    _min?: channelsMinOrderByAggregateInput
    _sum?: channelsSumOrderByAggregateInput
  }

  export type channelsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<channelsScalarWhereWithAggregatesInput>
    OR?: Enumerable<channelsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<channelsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type citiesWhereInput = {
    AND?: Enumerable<citiesWhereInput>
    OR?: Enumerable<citiesWhereInput>
    NOT?: Enumerable<citiesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    countries_id?: IntFilter | number
    isactive?: BoolNullableFilter | boolean | null
    countries?: XOR<CountriesRelationFilter, countriesWhereInput>
    companies?: CompaniesListRelationFilter
    contacts?: ContactsListRelationFilter
  }

  export type citiesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    countries_id?: SortOrder
    isactive?: SortOrder
    countries?: countriesOrderByWithRelationInput
    companies?: companiesOrderByRelationAggregateInput
    contacts?: contactsOrderByRelationAggregateInput
  }

  export type citiesWhereUniqueInput = {
    id?: number
  }

  export type citiesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    countries_id?: SortOrder
    isactive?: SortOrder
    _count?: citiesCountOrderByAggregateInput
    _avg?: citiesAvgOrderByAggregateInput
    _max?: citiesMaxOrderByAggregateInput
    _min?: citiesMinOrderByAggregateInput
    _sum?: citiesSumOrderByAggregateInput
  }

  export type citiesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<citiesScalarWhereWithAggregatesInput>
    OR?: Enumerable<citiesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<citiesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    countries_id?: IntWithAggregatesFilter | number
    isactive?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type companiesWhereInput = {
    AND?: Enumerable<companiesWhereInput>
    OR?: Enumerable<companiesWhereInput>
    NOT?: Enumerable<companiesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    address?: StringFilter | string
    email?: StringFilter | string
    phone?: StringFilter | string
    cities_id?: IntFilter | number
    isactive?: BoolNullableFilter | boolean | null
    cities?: XOR<CitiesRelationFilter, citiesWhereInput>
    contacts?: ContactsListRelationFilter
  }

  export type companiesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    cities_id?: SortOrder
    isactive?: SortOrder
    cities?: citiesOrderByWithRelationInput
    contacts?: contactsOrderByRelationAggregateInput
  }

  export type companiesWhereUniqueInput = {
    id?: number
  }

  export type companiesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    cities_id?: SortOrder
    isactive?: SortOrder
    _count?: companiesCountOrderByAggregateInput
    _avg?: companiesAvgOrderByAggregateInput
    _max?: companiesMaxOrderByAggregateInput
    _min?: companiesMinOrderByAggregateInput
    _sum?: companiesSumOrderByAggregateInput
  }

  export type companiesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<companiesScalarWhereWithAggregatesInput>
    OR?: Enumerable<companiesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<companiesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    address?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    phone?: StringWithAggregatesFilter | string
    cities_id?: IntWithAggregatesFilter | number
    isactive?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type contactsWhereInput = {
    AND?: Enumerable<contactsWhereInput>
    OR?: Enumerable<contactsWhereInput>
    NOT?: Enumerable<contactsWhereInput>
    id?: IntFilter | number
    username?: StringFilter | string
    lastname?: StringFilter | string
    email?: StringFilter | string
    job_tittle?: StringFilter | string
    create_time?: DateTimeNullableFilter | Date | string | null
    address?: StringNullableFilter | string | null
    interest?: IntNullableFilter | number | null
    imgUrl?: StringNullableFilter | string | null
    users_id?: IntFilter | number
    companies_id?: IntFilter | number
    cities_id?: IntFilter | number
    isactive?: BoolNullableFilter | boolean | null
    cities?: XOR<CitiesRelationFilter, citiesWhereInput>
    companies?: XOR<CompaniesRelationFilter, companiesWhereInput>
    users?: XOR<UsersRelationFilter, usersWhereInput>
    contacts_channels?: Contacts_channelsListRelationFilter
  }

  export type contactsOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    job_tittle?: SortOrder
    create_time?: SortOrder
    address?: SortOrder
    interest?: SortOrder
    imgUrl?: SortOrder
    users_id?: SortOrder
    companies_id?: SortOrder
    cities_id?: SortOrder
    isactive?: SortOrder
    cities?: citiesOrderByWithRelationInput
    companies?: companiesOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
    contacts_channels?: contacts_channelsOrderByRelationAggregateInput
  }

  export type contactsWhereUniqueInput = {
    id?: number
  }

  export type contactsOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    job_tittle?: SortOrder
    create_time?: SortOrder
    address?: SortOrder
    interest?: SortOrder
    imgUrl?: SortOrder
    users_id?: SortOrder
    companies_id?: SortOrder
    cities_id?: SortOrder
    isactive?: SortOrder
    _count?: contactsCountOrderByAggregateInput
    _avg?: contactsAvgOrderByAggregateInput
    _max?: contactsMaxOrderByAggregateInput
    _min?: contactsMinOrderByAggregateInput
    _sum?: contactsSumOrderByAggregateInput
  }

  export type contactsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<contactsScalarWhereWithAggregatesInput>
    OR?: Enumerable<contactsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<contactsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    username?: StringWithAggregatesFilter | string
    lastname?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    job_tittle?: StringWithAggregatesFilter | string
    create_time?: DateTimeNullableWithAggregatesFilter | Date | string | null
    address?: StringNullableWithAggregatesFilter | string | null
    interest?: IntNullableWithAggregatesFilter | number | null
    imgUrl?: StringNullableWithAggregatesFilter | string | null
    users_id?: IntWithAggregatesFilter | number
    companies_id?: IntWithAggregatesFilter | number
    cities_id?: IntWithAggregatesFilter | number
    isactive?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type contacts_channelsWhereInput = {
    AND?: Enumerable<contacts_channelsWhereInput>
    OR?: Enumerable<contacts_channelsWhereInput>
    NOT?: Enumerable<contacts_channelsWhereInput>
    id?: IntFilter | number
    acount?: StringFilter | string
    channels_id?: IntFilter | number
    preferences_id?: IntFilter | number
    contacts_id?: IntFilter | number
    channels?: XOR<ChannelsRelationFilter, channelsWhereInput>
    contacts?: XOR<ContactsRelationFilter, contactsWhereInput>
    preferences?: XOR<PreferencesRelationFilter, preferencesWhereInput>
  }

  export type contacts_channelsOrderByWithRelationInput = {
    id?: SortOrder
    acount?: SortOrder
    channels_id?: SortOrder
    preferences_id?: SortOrder
    contacts_id?: SortOrder
    channels?: channelsOrderByWithRelationInput
    contacts?: contactsOrderByWithRelationInput
    preferences?: preferencesOrderByWithRelationInput
  }

  export type contacts_channelsWhereUniqueInput = {
    id?: number
  }

  export type contacts_channelsOrderByWithAggregationInput = {
    id?: SortOrder
    acount?: SortOrder
    channels_id?: SortOrder
    preferences_id?: SortOrder
    contacts_id?: SortOrder
    _count?: contacts_channelsCountOrderByAggregateInput
    _avg?: contacts_channelsAvgOrderByAggregateInput
    _max?: contacts_channelsMaxOrderByAggregateInput
    _min?: contacts_channelsMinOrderByAggregateInput
    _sum?: contacts_channelsSumOrderByAggregateInput
  }

  export type contacts_channelsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<contacts_channelsScalarWhereWithAggregatesInput>
    OR?: Enumerable<contacts_channelsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<contacts_channelsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    acount?: StringWithAggregatesFilter | string
    channels_id?: IntWithAggregatesFilter | number
    preferences_id?: IntWithAggregatesFilter | number
    contacts_id?: IntWithAggregatesFilter | number
  }

  export type countriesWhereInput = {
    AND?: Enumerable<countriesWhereInput>
    OR?: Enumerable<countriesWhereInput>
    NOT?: Enumerable<countriesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    regions_id?: IntFilter | number
    isactive?: BoolNullableFilter | boolean | null
    regions?: XOR<RegionsRelationFilter, regionsWhereInput>
    cities?: CitiesListRelationFilter
  }

  export type countriesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    regions_id?: SortOrder
    isactive?: SortOrder
    regions?: regionsOrderByWithRelationInput
    cities?: citiesOrderByRelationAggregateInput
  }

  export type countriesWhereUniqueInput = {
    id?: number
  }

  export type countriesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    regions_id?: SortOrder
    isactive?: SortOrder
    _count?: countriesCountOrderByAggregateInput
    _avg?: countriesAvgOrderByAggregateInput
    _max?: countriesMaxOrderByAggregateInput
    _min?: countriesMinOrderByAggregateInput
    _sum?: countriesSumOrderByAggregateInput
  }

  export type countriesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<countriesScalarWhereWithAggregatesInput>
    OR?: Enumerable<countriesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<countriesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    regions_id?: IntWithAggregatesFilter | number
    isactive?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type preferencesWhereInput = {
    AND?: Enumerable<preferencesWhereInput>
    OR?: Enumerable<preferencesWhereInput>
    NOT?: Enumerable<preferencesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    contacts_channels?: Contacts_channelsListRelationFilter
  }

  export type preferencesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    contacts_channels?: contacts_channelsOrderByRelationAggregateInput
  }

  export type preferencesWhereUniqueInput = {
    id?: number
  }

  export type preferencesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: preferencesCountOrderByAggregateInput
    _avg?: preferencesAvgOrderByAggregateInput
    _max?: preferencesMaxOrderByAggregateInput
    _min?: preferencesMinOrderByAggregateInput
    _sum?: preferencesSumOrderByAggregateInput
  }

  export type preferencesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<preferencesScalarWhereWithAggregatesInput>
    OR?: Enumerable<preferencesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<preferencesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type regionsWhereInput = {
    AND?: Enumerable<regionsWhereInput>
    OR?: Enumerable<regionsWhereInput>
    NOT?: Enumerable<regionsWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    isactive?: BoolNullableFilter | boolean | null
    countries?: CountriesListRelationFilter
  }

  export type regionsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    isactive?: SortOrder
    countries?: countriesOrderByRelationAggregateInput
  }

  export type regionsWhereUniqueInput = {
    id?: number
  }

  export type regionsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    isactive?: SortOrder
    _count?: regionsCountOrderByAggregateInput
    _avg?: regionsAvgOrderByAggregateInput
    _max?: regionsMaxOrderByAggregateInput
    _min?: regionsMinOrderByAggregateInput
    _sum?: regionsSumOrderByAggregateInput
  }

  export type regionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<regionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<regionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<regionsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    isactive?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type usersWhereInput = {
    AND?: Enumerable<usersWhereInput>
    OR?: Enumerable<usersWhereInput>
    NOT?: Enumerable<usersWhereInput>
    id?: IntFilter | number
    username?: StringFilter | string
    lastname?: StringFilter | string
    email?: StringFilter | string
    password?: StringFilter | string
    create_time?: DateTimeNullableFilter | Date | string | null
    isadmin?: BoolNullableFilter | boolean | null
    isactive?: BoolNullableFilter | boolean | null
    contacts?: ContactsListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    create_time?: SortOrder
    isadmin?: SortOrder
    isactive?: SortOrder
    contacts?: contactsOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = {
    id?: number
    username?: string
    email?: string
  }

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    create_time?: SortOrder
    isadmin?: SortOrder
    isactive?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<usersScalarWhereWithAggregatesInput>
    OR?: Enumerable<usersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<usersScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    username?: StringWithAggregatesFilter | string
    lastname?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    create_time?: DateTimeNullableWithAggregatesFilter | Date | string | null
    isadmin?: BoolNullableWithAggregatesFilter | boolean | null
    isactive?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type channelsCreateInput = {
    name: string
    contacts_channels?: contacts_channelsCreateNestedManyWithoutChannelsInput
  }

  export type channelsUncheckedCreateInput = {
    id?: number
    name: string
    contacts_channels?: contacts_channelsUncheckedCreateNestedManyWithoutChannelsInput
  }

  export type channelsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    contacts_channels?: contacts_channelsUpdateManyWithoutChannelsInput
  }

  export type channelsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    contacts_channels?: contacts_channelsUncheckedUpdateManyWithoutChannelsInput
  }

  export type channelsCreateManyInput = {
    id?: number
    name: string
  }

  export type channelsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type channelsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type citiesCreateInput = {
    name: string
    isactive?: boolean | null
    countries: countriesCreateNestedOneWithoutCitiesInput
    companies?: companiesCreateNestedManyWithoutCitiesInput
    contacts?: contactsCreateNestedManyWithoutCitiesInput
  }

  export type citiesUncheckedCreateInput = {
    id?: number
    name: string
    countries_id: number
    isactive?: boolean | null
    companies?: companiesUncheckedCreateNestedManyWithoutCitiesInput
    contacts?: contactsUncheckedCreateNestedManyWithoutCitiesInput
  }

  export type citiesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    countries?: countriesUpdateOneRequiredWithoutCitiesInput
    companies?: companiesUpdateManyWithoutCitiesInput
    contacts?: contactsUpdateManyWithoutCitiesInput
  }

  export type citiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    countries_id?: IntFieldUpdateOperationsInput | number
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    companies?: companiesUncheckedUpdateManyWithoutCitiesInput
    contacts?: contactsUncheckedUpdateManyWithoutCitiesInput
  }

  export type citiesCreateManyInput = {
    id?: number
    name: string
    countries_id: number
    isactive?: boolean | null
  }

  export type citiesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type citiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    countries_id?: IntFieldUpdateOperationsInput | number
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type companiesCreateInput = {
    name: string
    address: string
    email: string
    phone: string
    isactive?: boolean | null
    cities: citiesCreateNestedOneWithoutCompaniesInput
    contacts?: contactsCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateInput = {
    id?: number
    name: string
    address: string
    email: string
    phone: string
    cities_id: number
    isactive?: boolean | null
    contacts?: contactsUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cities?: citiesUpdateOneRequiredWithoutCompaniesInput
    contacts?: contactsUpdateManyWithoutCompaniesInput
  }

  export type companiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    cities_id?: IntFieldUpdateOperationsInput | number
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contacts?: contactsUncheckedUpdateManyWithoutCompaniesInput
  }

  export type companiesCreateManyInput = {
    id?: number
    name: string
    address: string
    email: string
    phone: string
    cities_id: number
    isactive?: boolean | null
  }

  export type companiesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type companiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    cities_id?: IntFieldUpdateOperationsInput | number
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type contactsCreateInput = {
    username: string
    lastname: string
    email: string
    job_tittle: string
    create_time?: Date | string | null
    address?: string | null
    interest?: number | null
    imgUrl?: string | null
    isactive?: boolean | null
    cities: citiesCreateNestedOneWithoutContactsInput
    companies: companiesCreateNestedOneWithoutContactsInput
    users: usersCreateNestedOneWithoutContactsInput
    contacts_channels?: contacts_channelsCreateNestedManyWithoutContactsInput
  }

  export type contactsUncheckedCreateInput = {
    id?: number
    username: string
    lastname: string
    email: string
    job_tittle: string
    create_time?: Date | string | null
    address?: string | null
    interest?: number | null
    imgUrl?: string | null
    users_id: number
    companies_id: number
    cities_id: number
    isactive?: boolean | null
    contacts_channels?: contacts_channelsUncheckedCreateNestedManyWithoutContactsInput
  }

  export type contactsUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    job_tittle?: StringFieldUpdateOperationsInput | string
    create_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    interest?: NullableIntFieldUpdateOperationsInput | number | null
    imgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cities?: citiesUpdateOneRequiredWithoutContactsInput
    companies?: companiesUpdateOneRequiredWithoutContactsInput
    users?: usersUpdateOneRequiredWithoutContactsInput
    contacts_channels?: contacts_channelsUpdateManyWithoutContactsInput
  }

  export type contactsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    job_tittle?: StringFieldUpdateOperationsInput | string
    create_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    interest?: NullableIntFieldUpdateOperationsInput | number | null
    imgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    users_id?: IntFieldUpdateOperationsInput | number
    companies_id?: IntFieldUpdateOperationsInput | number
    cities_id?: IntFieldUpdateOperationsInput | number
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contacts_channels?: contacts_channelsUncheckedUpdateManyWithoutContactsInput
  }

  export type contactsCreateManyInput = {
    id?: number
    username: string
    lastname: string
    email: string
    job_tittle: string
    create_time?: Date | string | null
    address?: string | null
    interest?: number | null
    imgUrl?: string | null
    users_id: number
    companies_id: number
    cities_id: number
    isactive?: boolean | null
  }

  export type contactsUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    job_tittle?: StringFieldUpdateOperationsInput | string
    create_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    interest?: NullableIntFieldUpdateOperationsInput | number | null
    imgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type contactsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    job_tittle?: StringFieldUpdateOperationsInput | string
    create_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    interest?: NullableIntFieldUpdateOperationsInput | number | null
    imgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    users_id?: IntFieldUpdateOperationsInput | number
    companies_id?: IntFieldUpdateOperationsInput | number
    cities_id?: IntFieldUpdateOperationsInput | number
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type contacts_channelsCreateInput = {
    acount: string
    channels: channelsCreateNestedOneWithoutContacts_channelsInput
    contacts: contactsCreateNestedOneWithoutContacts_channelsInput
    preferences: preferencesCreateNestedOneWithoutContacts_channelsInput
  }

  export type contacts_channelsUncheckedCreateInput = {
    id?: number
    acount: string
    channels_id: number
    preferences_id: number
    contacts_id: number
  }

  export type contacts_channelsUpdateInput = {
    acount?: StringFieldUpdateOperationsInput | string
    channels?: channelsUpdateOneRequiredWithoutContacts_channelsInput
    contacts?: contactsUpdateOneRequiredWithoutContacts_channelsInput
    preferences?: preferencesUpdateOneRequiredWithoutContacts_channelsInput
  }

  export type contacts_channelsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    acount?: StringFieldUpdateOperationsInput | string
    channels_id?: IntFieldUpdateOperationsInput | number
    preferences_id?: IntFieldUpdateOperationsInput | number
    contacts_id?: IntFieldUpdateOperationsInput | number
  }

  export type contacts_channelsCreateManyInput = {
    id?: number
    acount: string
    channels_id: number
    preferences_id: number
    contacts_id: number
  }

  export type contacts_channelsUpdateManyMutationInput = {
    acount?: StringFieldUpdateOperationsInput | string
  }

  export type contacts_channelsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    acount?: StringFieldUpdateOperationsInput | string
    channels_id?: IntFieldUpdateOperationsInput | number
    preferences_id?: IntFieldUpdateOperationsInput | number
    contacts_id?: IntFieldUpdateOperationsInput | number
  }

  export type countriesCreateInput = {
    name: string
    isactive?: boolean | null
    regions: regionsCreateNestedOneWithoutCountriesInput
    cities?: citiesCreateNestedManyWithoutCountriesInput
  }

  export type countriesUncheckedCreateInput = {
    id?: number
    name: string
    regions_id: number
    isactive?: boolean | null
    cities?: citiesUncheckedCreateNestedManyWithoutCountriesInput
  }

  export type countriesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    regions?: regionsUpdateOneRequiredWithoutCountriesInput
    cities?: citiesUpdateManyWithoutCountriesInput
  }

  export type countriesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    regions_id?: IntFieldUpdateOperationsInput | number
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cities?: citiesUncheckedUpdateManyWithoutCountriesInput
  }

  export type countriesCreateManyInput = {
    id?: number
    name: string
    regions_id: number
    isactive?: boolean | null
  }

  export type countriesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type countriesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    regions_id?: IntFieldUpdateOperationsInput | number
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type preferencesCreateInput = {
    name: string
    contacts_channels?: contacts_channelsCreateNestedManyWithoutPreferencesInput
  }

  export type preferencesUncheckedCreateInput = {
    id?: number
    name: string
    contacts_channels?: contacts_channelsUncheckedCreateNestedManyWithoutPreferencesInput
  }

  export type preferencesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    contacts_channels?: contacts_channelsUpdateManyWithoutPreferencesInput
  }

  export type preferencesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    contacts_channels?: contacts_channelsUncheckedUpdateManyWithoutPreferencesInput
  }

  export type preferencesCreateManyInput = {
    id?: number
    name: string
  }

  export type preferencesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type preferencesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type regionsCreateInput = {
    name: string
    isactive?: boolean | null
    countries?: countriesCreateNestedManyWithoutRegionsInput
  }

  export type regionsUncheckedCreateInput = {
    id?: number
    name: string
    isactive?: boolean | null
    countries?: countriesUncheckedCreateNestedManyWithoutRegionsInput
  }

  export type regionsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    countries?: countriesUpdateManyWithoutRegionsInput
  }

  export type regionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    countries?: countriesUncheckedUpdateManyWithoutRegionsInput
  }

  export type regionsCreateManyInput = {
    id?: number
    name: string
    isactive?: boolean | null
  }

  export type regionsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type regionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type usersCreateInput = {
    username: string
    lastname: string
    email: string
    password: string
    create_time?: Date | string | null
    isadmin?: boolean | null
    isactive?: boolean | null
    contacts?: contactsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    id?: number
    username: string
    lastname: string
    email: string
    password: string
    create_time?: Date | string | null
    isadmin?: boolean | null
    isactive?: boolean | null
    contacts?: contactsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    create_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isadmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contacts?: contactsUpdateManyWithoutUsersInput
  }

  export type usersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    create_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isadmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contacts?: contactsUncheckedUpdateManyWithoutUsersInput
  }

  export type usersCreateManyInput = {
    id?: number
    username: string
    lastname: string
    email: string
    password: string
    create_time?: Date | string | null
    isadmin?: boolean | null
    isactive?: boolean | null
  }

  export type usersUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    create_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isadmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type usersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    create_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isadmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type Contacts_channelsListRelationFilter = {
    every?: contacts_channelsWhereInput
    some?: contacts_channelsWhereInput
    none?: contacts_channelsWhereInput
  }

  export type contacts_channelsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type channelsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type channelsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type channelsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type channelsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type channelsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type CountriesRelationFilter = {
    is?: countriesWhereInput
    isNot?: countriesWhereInput
  }

  export type CompaniesListRelationFilter = {
    every?: companiesWhereInput
    some?: companiesWhereInput
    none?: companiesWhereInput
  }

  export type ContactsListRelationFilter = {
    every?: contactsWhereInput
    some?: contactsWhereInput
    none?: contactsWhereInput
  }

  export type companiesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type contactsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type citiesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    countries_id?: SortOrder
    isactive?: SortOrder
  }

  export type citiesAvgOrderByAggregateInput = {
    id?: SortOrder
    countries_id?: SortOrder
  }

  export type citiesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    countries_id?: SortOrder
    isactive?: SortOrder
  }

  export type citiesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    countries_id?: SortOrder
    isactive?: SortOrder
  }

  export type citiesSumOrderByAggregateInput = {
    id?: SortOrder
    countries_id?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type CitiesRelationFilter = {
    is?: citiesWhereInput
    isNot?: citiesWhereInput
  }

  export type companiesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    cities_id?: SortOrder
    isactive?: SortOrder
  }

  export type companiesAvgOrderByAggregateInput = {
    id?: SortOrder
    cities_id?: SortOrder
  }

  export type companiesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    cities_id?: SortOrder
    isactive?: SortOrder
  }

  export type companiesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    cities_id?: SortOrder
    isactive?: SortOrder
  }

  export type companiesSumOrderByAggregateInput = {
    id?: SortOrder
    cities_id?: SortOrder
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type CompaniesRelationFilter = {
    is?: companiesWhereInput
    isNot?: companiesWhereInput
  }

  export type UsersRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type contactsCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    job_tittle?: SortOrder
    create_time?: SortOrder
    address?: SortOrder
    interest?: SortOrder
    imgUrl?: SortOrder
    users_id?: SortOrder
    companies_id?: SortOrder
    cities_id?: SortOrder
    isactive?: SortOrder
  }

  export type contactsAvgOrderByAggregateInput = {
    id?: SortOrder
    interest?: SortOrder
    users_id?: SortOrder
    companies_id?: SortOrder
    cities_id?: SortOrder
  }

  export type contactsMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    job_tittle?: SortOrder
    create_time?: SortOrder
    address?: SortOrder
    interest?: SortOrder
    imgUrl?: SortOrder
    users_id?: SortOrder
    companies_id?: SortOrder
    cities_id?: SortOrder
    isactive?: SortOrder
  }

  export type contactsMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    job_tittle?: SortOrder
    create_time?: SortOrder
    address?: SortOrder
    interest?: SortOrder
    imgUrl?: SortOrder
    users_id?: SortOrder
    companies_id?: SortOrder
    cities_id?: SortOrder
    isactive?: SortOrder
  }

  export type contactsSumOrderByAggregateInput = {
    id?: SortOrder
    interest?: SortOrder
    users_id?: SortOrder
    companies_id?: SortOrder
    cities_id?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type ChannelsRelationFilter = {
    is?: channelsWhereInput
    isNot?: channelsWhereInput
  }

  export type ContactsRelationFilter = {
    is?: contactsWhereInput
    isNot?: contactsWhereInput
  }

  export type PreferencesRelationFilter = {
    is?: preferencesWhereInput
    isNot?: preferencesWhereInput
  }

  export type contacts_channelsCountOrderByAggregateInput = {
    id?: SortOrder
    acount?: SortOrder
    channels_id?: SortOrder
    preferences_id?: SortOrder
    contacts_id?: SortOrder
  }

  export type contacts_channelsAvgOrderByAggregateInput = {
    id?: SortOrder
    channels_id?: SortOrder
    preferences_id?: SortOrder
    contacts_id?: SortOrder
  }

  export type contacts_channelsMaxOrderByAggregateInput = {
    id?: SortOrder
    acount?: SortOrder
    channels_id?: SortOrder
    preferences_id?: SortOrder
    contacts_id?: SortOrder
  }

  export type contacts_channelsMinOrderByAggregateInput = {
    id?: SortOrder
    acount?: SortOrder
    channels_id?: SortOrder
    preferences_id?: SortOrder
    contacts_id?: SortOrder
  }

  export type contacts_channelsSumOrderByAggregateInput = {
    id?: SortOrder
    channels_id?: SortOrder
    preferences_id?: SortOrder
    contacts_id?: SortOrder
  }

  export type RegionsRelationFilter = {
    is?: regionsWhereInput
    isNot?: regionsWhereInput
  }

  export type CitiesListRelationFilter = {
    every?: citiesWhereInput
    some?: citiesWhereInput
    none?: citiesWhereInput
  }

  export type citiesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type countriesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    regions_id?: SortOrder
    isactive?: SortOrder
  }

  export type countriesAvgOrderByAggregateInput = {
    id?: SortOrder
    regions_id?: SortOrder
  }

  export type countriesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    regions_id?: SortOrder
    isactive?: SortOrder
  }

  export type countriesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    regions_id?: SortOrder
    isactive?: SortOrder
  }

  export type countriesSumOrderByAggregateInput = {
    id?: SortOrder
    regions_id?: SortOrder
  }

  export type preferencesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type preferencesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type preferencesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type preferencesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type preferencesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CountriesListRelationFilter = {
    every?: countriesWhereInput
    some?: countriesWhereInput
    none?: countriesWhereInput
  }

  export type countriesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type regionsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isactive?: SortOrder
  }

  export type regionsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type regionsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isactive?: SortOrder
  }

  export type regionsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isactive?: SortOrder
  }

  export type regionsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    create_time?: SortOrder
    isadmin?: SortOrder
    isactive?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    create_time?: SortOrder
    isadmin?: SortOrder
    isactive?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    create_time?: SortOrder
    isadmin?: SortOrder
    isactive?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type contacts_channelsCreateNestedManyWithoutChannelsInput = {
    create?: XOR<Enumerable<contacts_channelsCreateWithoutChannelsInput>, Enumerable<contacts_channelsUncheckedCreateWithoutChannelsInput>>
    connectOrCreate?: Enumerable<contacts_channelsCreateOrConnectWithoutChannelsInput>
    createMany?: contacts_channelsCreateManyChannelsInputEnvelope
    connect?: Enumerable<contacts_channelsWhereUniqueInput>
  }

  export type contacts_channelsUncheckedCreateNestedManyWithoutChannelsInput = {
    create?: XOR<Enumerable<contacts_channelsCreateWithoutChannelsInput>, Enumerable<contacts_channelsUncheckedCreateWithoutChannelsInput>>
    connectOrCreate?: Enumerable<contacts_channelsCreateOrConnectWithoutChannelsInput>
    createMany?: contacts_channelsCreateManyChannelsInputEnvelope
    connect?: Enumerable<contacts_channelsWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type contacts_channelsUpdateManyWithoutChannelsInput = {
    create?: XOR<Enumerable<contacts_channelsCreateWithoutChannelsInput>, Enumerable<contacts_channelsUncheckedCreateWithoutChannelsInput>>
    connectOrCreate?: Enumerable<contacts_channelsCreateOrConnectWithoutChannelsInput>
    upsert?: Enumerable<contacts_channelsUpsertWithWhereUniqueWithoutChannelsInput>
    createMany?: contacts_channelsCreateManyChannelsInputEnvelope
    connect?: Enumerable<contacts_channelsWhereUniqueInput>
    set?: Enumerable<contacts_channelsWhereUniqueInput>
    disconnect?: Enumerable<contacts_channelsWhereUniqueInput>
    delete?: Enumerable<contacts_channelsWhereUniqueInput>
    update?: Enumerable<contacts_channelsUpdateWithWhereUniqueWithoutChannelsInput>
    updateMany?: Enumerable<contacts_channelsUpdateManyWithWhereWithoutChannelsInput>
    deleteMany?: Enumerable<contacts_channelsScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type contacts_channelsUncheckedUpdateManyWithoutChannelsInput = {
    create?: XOR<Enumerable<contacts_channelsCreateWithoutChannelsInput>, Enumerable<contacts_channelsUncheckedCreateWithoutChannelsInput>>
    connectOrCreate?: Enumerable<contacts_channelsCreateOrConnectWithoutChannelsInput>
    upsert?: Enumerable<contacts_channelsUpsertWithWhereUniqueWithoutChannelsInput>
    createMany?: contacts_channelsCreateManyChannelsInputEnvelope
    connect?: Enumerable<contacts_channelsWhereUniqueInput>
    set?: Enumerable<contacts_channelsWhereUniqueInput>
    disconnect?: Enumerable<contacts_channelsWhereUniqueInput>
    delete?: Enumerable<contacts_channelsWhereUniqueInput>
    update?: Enumerable<contacts_channelsUpdateWithWhereUniqueWithoutChannelsInput>
    updateMany?: Enumerable<contacts_channelsUpdateManyWithWhereWithoutChannelsInput>
    deleteMany?: Enumerable<contacts_channelsScalarWhereInput>
  }

  export type countriesCreateNestedOneWithoutCitiesInput = {
    create?: XOR<countriesCreateWithoutCitiesInput, countriesUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: countriesCreateOrConnectWithoutCitiesInput
    connect?: countriesWhereUniqueInput
  }

  export type companiesCreateNestedManyWithoutCitiesInput = {
    create?: XOR<Enumerable<companiesCreateWithoutCitiesInput>, Enumerable<companiesUncheckedCreateWithoutCitiesInput>>
    connectOrCreate?: Enumerable<companiesCreateOrConnectWithoutCitiesInput>
    createMany?: companiesCreateManyCitiesInputEnvelope
    connect?: Enumerable<companiesWhereUniqueInput>
  }

  export type contactsCreateNestedManyWithoutCitiesInput = {
    create?: XOR<Enumerable<contactsCreateWithoutCitiesInput>, Enumerable<contactsUncheckedCreateWithoutCitiesInput>>
    connectOrCreate?: Enumerable<contactsCreateOrConnectWithoutCitiesInput>
    createMany?: contactsCreateManyCitiesInputEnvelope
    connect?: Enumerable<contactsWhereUniqueInput>
  }

  export type companiesUncheckedCreateNestedManyWithoutCitiesInput = {
    create?: XOR<Enumerable<companiesCreateWithoutCitiesInput>, Enumerable<companiesUncheckedCreateWithoutCitiesInput>>
    connectOrCreate?: Enumerable<companiesCreateOrConnectWithoutCitiesInput>
    createMany?: companiesCreateManyCitiesInputEnvelope
    connect?: Enumerable<companiesWhereUniqueInput>
  }

  export type contactsUncheckedCreateNestedManyWithoutCitiesInput = {
    create?: XOR<Enumerable<contactsCreateWithoutCitiesInput>, Enumerable<contactsUncheckedCreateWithoutCitiesInput>>
    connectOrCreate?: Enumerable<contactsCreateOrConnectWithoutCitiesInput>
    createMany?: contactsCreateManyCitiesInputEnvelope
    connect?: Enumerable<contactsWhereUniqueInput>
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type countriesUpdateOneRequiredWithoutCitiesInput = {
    create?: XOR<countriesCreateWithoutCitiesInput, countriesUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: countriesCreateOrConnectWithoutCitiesInput
    upsert?: countriesUpsertWithoutCitiesInput
    connect?: countriesWhereUniqueInput
    update?: XOR<countriesUpdateWithoutCitiesInput, countriesUncheckedUpdateWithoutCitiesInput>
  }

  export type companiesUpdateManyWithoutCitiesInput = {
    create?: XOR<Enumerable<companiesCreateWithoutCitiesInput>, Enumerable<companiesUncheckedCreateWithoutCitiesInput>>
    connectOrCreate?: Enumerable<companiesCreateOrConnectWithoutCitiesInput>
    upsert?: Enumerable<companiesUpsertWithWhereUniqueWithoutCitiesInput>
    createMany?: companiesCreateManyCitiesInputEnvelope
    connect?: Enumerable<companiesWhereUniqueInput>
    set?: Enumerable<companiesWhereUniqueInput>
    disconnect?: Enumerable<companiesWhereUniqueInput>
    delete?: Enumerable<companiesWhereUniqueInput>
    update?: Enumerable<companiesUpdateWithWhereUniqueWithoutCitiesInput>
    updateMany?: Enumerable<companiesUpdateManyWithWhereWithoutCitiesInput>
    deleteMany?: Enumerable<companiesScalarWhereInput>
  }

  export type contactsUpdateManyWithoutCitiesInput = {
    create?: XOR<Enumerable<contactsCreateWithoutCitiesInput>, Enumerable<contactsUncheckedCreateWithoutCitiesInput>>
    connectOrCreate?: Enumerable<contactsCreateOrConnectWithoutCitiesInput>
    upsert?: Enumerable<contactsUpsertWithWhereUniqueWithoutCitiesInput>
    createMany?: contactsCreateManyCitiesInputEnvelope
    connect?: Enumerable<contactsWhereUniqueInput>
    set?: Enumerable<contactsWhereUniqueInput>
    disconnect?: Enumerable<contactsWhereUniqueInput>
    delete?: Enumerable<contactsWhereUniqueInput>
    update?: Enumerable<contactsUpdateWithWhereUniqueWithoutCitiesInput>
    updateMany?: Enumerable<contactsUpdateManyWithWhereWithoutCitiesInput>
    deleteMany?: Enumerable<contactsScalarWhereInput>
  }

  export type companiesUncheckedUpdateManyWithoutCitiesInput = {
    create?: XOR<Enumerable<companiesCreateWithoutCitiesInput>, Enumerable<companiesUncheckedCreateWithoutCitiesInput>>
    connectOrCreate?: Enumerable<companiesCreateOrConnectWithoutCitiesInput>
    upsert?: Enumerable<companiesUpsertWithWhereUniqueWithoutCitiesInput>
    createMany?: companiesCreateManyCitiesInputEnvelope
    connect?: Enumerable<companiesWhereUniqueInput>
    set?: Enumerable<companiesWhereUniqueInput>
    disconnect?: Enumerable<companiesWhereUniqueInput>
    delete?: Enumerable<companiesWhereUniqueInput>
    update?: Enumerable<companiesUpdateWithWhereUniqueWithoutCitiesInput>
    updateMany?: Enumerable<companiesUpdateManyWithWhereWithoutCitiesInput>
    deleteMany?: Enumerable<companiesScalarWhereInput>
  }

  export type contactsUncheckedUpdateManyWithoutCitiesInput = {
    create?: XOR<Enumerable<contactsCreateWithoutCitiesInput>, Enumerable<contactsUncheckedCreateWithoutCitiesInput>>
    connectOrCreate?: Enumerable<contactsCreateOrConnectWithoutCitiesInput>
    upsert?: Enumerable<contactsUpsertWithWhereUniqueWithoutCitiesInput>
    createMany?: contactsCreateManyCitiesInputEnvelope
    connect?: Enumerable<contactsWhereUniqueInput>
    set?: Enumerable<contactsWhereUniqueInput>
    disconnect?: Enumerable<contactsWhereUniqueInput>
    delete?: Enumerable<contactsWhereUniqueInput>
    update?: Enumerable<contactsUpdateWithWhereUniqueWithoutCitiesInput>
    updateMany?: Enumerable<contactsUpdateManyWithWhereWithoutCitiesInput>
    deleteMany?: Enumerable<contactsScalarWhereInput>
  }

  export type citiesCreateNestedOneWithoutCompaniesInput = {
    create?: XOR<citiesCreateWithoutCompaniesInput, citiesUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: citiesCreateOrConnectWithoutCompaniesInput
    connect?: citiesWhereUniqueInput
  }

  export type contactsCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<contactsCreateWithoutCompaniesInput>, Enumerable<contactsUncheckedCreateWithoutCompaniesInput>>
    connectOrCreate?: Enumerable<contactsCreateOrConnectWithoutCompaniesInput>
    createMany?: contactsCreateManyCompaniesInputEnvelope
    connect?: Enumerable<contactsWhereUniqueInput>
  }

  export type contactsUncheckedCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<contactsCreateWithoutCompaniesInput>, Enumerable<contactsUncheckedCreateWithoutCompaniesInput>>
    connectOrCreate?: Enumerable<contactsCreateOrConnectWithoutCompaniesInput>
    createMany?: contactsCreateManyCompaniesInputEnvelope
    connect?: Enumerable<contactsWhereUniqueInput>
  }

  export type citiesUpdateOneRequiredWithoutCompaniesInput = {
    create?: XOR<citiesCreateWithoutCompaniesInput, citiesUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: citiesCreateOrConnectWithoutCompaniesInput
    upsert?: citiesUpsertWithoutCompaniesInput
    connect?: citiesWhereUniqueInput
    update?: XOR<citiesUpdateWithoutCompaniesInput, citiesUncheckedUpdateWithoutCompaniesInput>
  }

  export type contactsUpdateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<contactsCreateWithoutCompaniesInput>, Enumerable<contactsUncheckedCreateWithoutCompaniesInput>>
    connectOrCreate?: Enumerable<contactsCreateOrConnectWithoutCompaniesInput>
    upsert?: Enumerable<contactsUpsertWithWhereUniqueWithoutCompaniesInput>
    createMany?: contactsCreateManyCompaniesInputEnvelope
    connect?: Enumerable<contactsWhereUniqueInput>
    set?: Enumerable<contactsWhereUniqueInput>
    disconnect?: Enumerable<contactsWhereUniqueInput>
    delete?: Enumerable<contactsWhereUniqueInput>
    update?: Enumerable<contactsUpdateWithWhereUniqueWithoutCompaniesInput>
    updateMany?: Enumerable<contactsUpdateManyWithWhereWithoutCompaniesInput>
    deleteMany?: Enumerable<contactsScalarWhereInput>
  }

  export type contactsUncheckedUpdateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<contactsCreateWithoutCompaniesInput>, Enumerable<contactsUncheckedCreateWithoutCompaniesInput>>
    connectOrCreate?: Enumerable<contactsCreateOrConnectWithoutCompaniesInput>
    upsert?: Enumerable<contactsUpsertWithWhereUniqueWithoutCompaniesInput>
    createMany?: contactsCreateManyCompaniesInputEnvelope
    connect?: Enumerable<contactsWhereUniqueInput>
    set?: Enumerable<contactsWhereUniqueInput>
    disconnect?: Enumerable<contactsWhereUniqueInput>
    delete?: Enumerable<contactsWhereUniqueInput>
    update?: Enumerable<contactsUpdateWithWhereUniqueWithoutCompaniesInput>
    updateMany?: Enumerable<contactsUpdateManyWithWhereWithoutCompaniesInput>
    deleteMany?: Enumerable<contactsScalarWhereInput>
  }

  export type citiesCreateNestedOneWithoutContactsInput = {
    create?: XOR<citiesCreateWithoutContactsInput, citiesUncheckedCreateWithoutContactsInput>
    connectOrCreate?: citiesCreateOrConnectWithoutContactsInput
    connect?: citiesWhereUniqueInput
  }

  export type companiesCreateNestedOneWithoutContactsInput = {
    create?: XOR<companiesCreateWithoutContactsInput, companiesUncheckedCreateWithoutContactsInput>
    connectOrCreate?: companiesCreateOrConnectWithoutContactsInput
    connect?: companiesWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutContactsInput = {
    create?: XOR<usersCreateWithoutContactsInput, usersUncheckedCreateWithoutContactsInput>
    connectOrCreate?: usersCreateOrConnectWithoutContactsInput
    connect?: usersWhereUniqueInput
  }

  export type contacts_channelsCreateNestedManyWithoutContactsInput = {
    create?: XOR<Enumerable<contacts_channelsCreateWithoutContactsInput>, Enumerable<contacts_channelsUncheckedCreateWithoutContactsInput>>
    connectOrCreate?: Enumerable<contacts_channelsCreateOrConnectWithoutContactsInput>
    createMany?: contacts_channelsCreateManyContactsInputEnvelope
    connect?: Enumerable<contacts_channelsWhereUniqueInput>
  }

  export type contacts_channelsUncheckedCreateNestedManyWithoutContactsInput = {
    create?: XOR<Enumerable<contacts_channelsCreateWithoutContactsInput>, Enumerable<contacts_channelsUncheckedCreateWithoutContactsInput>>
    connectOrCreate?: Enumerable<contacts_channelsCreateOrConnectWithoutContactsInput>
    createMany?: contacts_channelsCreateManyContactsInputEnvelope
    connect?: Enumerable<contacts_channelsWhereUniqueInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type citiesUpdateOneRequiredWithoutContactsInput = {
    create?: XOR<citiesCreateWithoutContactsInput, citiesUncheckedCreateWithoutContactsInput>
    connectOrCreate?: citiesCreateOrConnectWithoutContactsInput
    upsert?: citiesUpsertWithoutContactsInput
    connect?: citiesWhereUniqueInput
    update?: XOR<citiesUpdateWithoutContactsInput, citiesUncheckedUpdateWithoutContactsInput>
  }

  export type companiesUpdateOneRequiredWithoutContactsInput = {
    create?: XOR<companiesCreateWithoutContactsInput, companiesUncheckedCreateWithoutContactsInput>
    connectOrCreate?: companiesCreateOrConnectWithoutContactsInput
    upsert?: companiesUpsertWithoutContactsInput
    connect?: companiesWhereUniqueInput
    update?: XOR<companiesUpdateWithoutContactsInput, companiesUncheckedUpdateWithoutContactsInput>
  }

  export type usersUpdateOneRequiredWithoutContactsInput = {
    create?: XOR<usersCreateWithoutContactsInput, usersUncheckedCreateWithoutContactsInput>
    connectOrCreate?: usersCreateOrConnectWithoutContactsInput
    upsert?: usersUpsertWithoutContactsInput
    connect?: usersWhereUniqueInput
    update?: XOR<usersUpdateWithoutContactsInput, usersUncheckedUpdateWithoutContactsInput>
  }

  export type contacts_channelsUpdateManyWithoutContactsInput = {
    create?: XOR<Enumerable<contacts_channelsCreateWithoutContactsInput>, Enumerable<contacts_channelsUncheckedCreateWithoutContactsInput>>
    connectOrCreate?: Enumerable<contacts_channelsCreateOrConnectWithoutContactsInput>
    upsert?: Enumerable<contacts_channelsUpsertWithWhereUniqueWithoutContactsInput>
    createMany?: contacts_channelsCreateManyContactsInputEnvelope
    connect?: Enumerable<contacts_channelsWhereUniqueInput>
    set?: Enumerable<contacts_channelsWhereUniqueInput>
    disconnect?: Enumerable<contacts_channelsWhereUniqueInput>
    delete?: Enumerable<contacts_channelsWhereUniqueInput>
    update?: Enumerable<contacts_channelsUpdateWithWhereUniqueWithoutContactsInput>
    updateMany?: Enumerable<contacts_channelsUpdateManyWithWhereWithoutContactsInput>
    deleteMany?: Enumerable<contacts_channelsScalarWhereInput>
  }

  export type contacts_channelsUncheckedUpdateManyWithoutContactsInput = {
    create?: XOR<Enumerable<contacts_channelsCreateWithoutContactsInput>, Enumerable<contacts_channelsUncheckedCreateWithoutContactsInput>>
    connectOrCreate?: Enumerable<contacts_channelsCreateOrConnectWithoutContactsInput>
    upsert?: Enumerable<contacts_channelsUpsertWithWhereUniqueWithoutContactsInput>
    createMany?: contacts_channelsCreateManyContactsInputEnvelope
    connect?: Enumerable<contacts_channelsWhereUniqueInput>
    set?: Enumerable<contacts_channelsWhereUniqueInput>
    disconnect?: Enumerable<contacts_channelsWhereUniqueInput>
    delete?: Enumerable<contacts_channelsWhereUniqueInput>
    update?: Enumerable<contacts_channelsUpdateWithWhereUniqueWithoutContactsInput>
    updateMany?: Enumerable<contacts_channelsUpdateManyWithWhereWithoutContactsInput>
    deleteMany?: Enumerable<contacts_channelsScalarWhereInput>
  }

  export type channelsCreateNestedOneWithoutContacts_channelsInput = {
    create?: XOR<channelsCreateWithoutContacts_channelsInput, channelsUncheckedCreateWithoutContacts_channelsInput>
    connectOrCreate?: channelsCreateOrConnectWithoutContacts_channelsInput
    connect?: channelsWhereUniqueInput
  }

  export type contactsCreateNestedOneWithoutContacts_channelsInput = {
    create?: XOR<contactsCreateWithoutContacts_channelsInput, contactsUncheckedCreateWithoutContacts_channelsInput>
    connectOrCreate?: contactsCreateOrConnectWithoutContacts_channelsInput
    connect?: contactsWhereUniqueInput
  }

  export type preferencesCreateNestedOneWithoutContacts_channelsInput = {
    create?: XOR<preferencesCreateWithoutContacts_channelsInput, preferencesUncheckedCreateWithoutContacts_channelsInput>
    connectOrCreate?: preferencesCreateOrConnectWithoutContacts_channelsInput
    connect?: preferencesWhereUniqueInput
  }

  export type channelsUpdateOneRequiredWithoutContacts_channelsInput = {
    create?: XOR<channelsCreateWithoutContacts_channelsInput, channelsUncheckedCreateWithoutContacts_channelsInput>
    connectOrCreate?: channelsCreateOrConnectWithoutContacts_channelsInput
    upsert?: channelsUpsertWithoutContacts_channelsInput
    connect?: channelsWhereUniqueInput
    update?: XOR<channelsUpdateWithoutContacts_channelsInput, channelsUncheckedUpdateWithoutContacts_channelsInput>
  }

  export type contactsUpdateOneRequiredWithoutContacts_channelsInput = {
    create?: XOR<contactsCreateWithoutContacts_channelsInput, contactsUncheckedCreateWithoutContacts_channelsInput>
    connectOrCreate?: contactsCreateOrConnectWithoutContacts_channelsInput
    upsert?: contactsUpsertWithoutContacts_channelsInput
    connect?: contactsWhereUniqueInput
    update?: XOR<contactsUpdateWithoutContacts_channelsInput, contactsUncheckedUpdateWithoutContacts_channelsInput>
  }

  export type preferencesUpdateOneRequiredWithoutContacts_channelsInput = {
    create?: XOR<preferencesCreateWithoutContacts_channelsInput, preferencesUncheckedCreateWithoutContacts_channelsInput>
    connectOrCreate?: preferencesCreateOrConnectWithoutContacts_channelsInput
    upsert?: preferencesUpsertWithoutContacts_channelsInput
    connect?: preferencesWhereUniqueInput
    update?: XOR<preferencesUpdateWithoutContacts_channelsInput, preferencesUncheckedUpdateWithoutContacts_channelsInput>
  }

  export type regionsCreateNestedOneWithoutCountriesInput = {
    create?: XOR<regionsCreateWithoutCountriesInput, regionsUncheckedCreateWithoutCountriesInput>
    connectOrCreate?: regionsCreateOrConnectWithoutCountriesInput
    connect?: regionsWhereUniqueInput
  }

  export type citiesCreateNestedManyWithoutCountriesInput = {
    create?: XOR<Enumerable<citiesCreateWithoutCountriesInput>, Enumerable<citiesUncheckedCreateWithoutCountriesInput>>
    connectOrCreate?: Enumerable<citiesCreateOrConnectWithoutCountriesInput>
    createMany?: citiesCreateManyCountriesInputEnvelope
    connect?: Enumerable<citiesWhereUniqueInput>
  }

  export type citiesUncheckedCreateNestedManyWithoutCountriesInput = {
    create?: XOR<Enumerable<citiesCreateWithoutCountriesInput>, Enumerable<citiesUncheckedCreateWithoutCountriesInput>>
    connectOrCreate?: Enumerable<citiesCreateOrConnectWithoutCountriesInput>
    createMany?: citiesCreateManyCountriesInputEnvelope
    connect?: Enumerable<citiesWhereUniqueInput>
  }

  export type regionsUpdateOneRequiredWithoutCountriesInput = {
    create?: XOR<regionsCreateWithoutCountriesInput, regionsUncheckedCreateWithoutCountriesInput>
    connectOrCreate?: regionsCreateOrConnectWithoutCountriesInput
    upsert?: regionsUpsertWithoutCountriesInput
    connect?: regionsWhereUniqueInput
    update?: XOR<regionsUpdateWithoutCountriesInput, regionsUncheckedUpdateWithoutCountriesInput>
  }

  export type citiesUpdateManyWithoutCountriesInput = {
    create?: XOR<Enumerable<citiesCreateWithoutCountriesInput>, Enumerable<citiesUncheckedCreateWithoutCountriesInput>>
    connectOrCreate?: Enumerable<citiesCreateOrConnectWithoutCountriesInput>
    upsert?: Enumerable<citiesUpsertWithWhereUniqueWithoutCountriesInput>
    createMany?: citiesCreateManyCountriesInputEnvelope
    connect?: Enumerable<citiesWhereUniqueInput>
    set?: Enumerable<citiesWhereUniqueInput>
    disconnect?: Enumerable<citiesWhereUniqueInput>
    delete?: Enumerable<citiesWhereUniqueInput>
    update?: Enumerable<citiesUpdateWithWhereUniqueWithoutCountriesInput>
    updateMany?: Enumerable<citiesUpdateManyWithWhereWithoutCountriesInput>
    deleteMany?: Enumerable<citiesScalarWhereInput>
  }

  export type citiesUncheckedUpdateManyWithoutCountriesInput = {
    create?: XOR<Enumerable<citiesCreateWithoutCountriesInput>, Enumerable<citiesUncheckedCreateWithoutCountriesInput>>
    connectOrCreate?: Enumerable<citiesCreateOrConnectWithoutCountriesInput>
    upsert?: Enumerable<citiesUpsertWithWhereUniqueWithoutCountriesInput>
    createMany?: citiesCreateManyCountriesInputEnvelope
    connect?: Enumerable<citiesWhereUniqueInput>
    set?: Enumerable<citiesWhereUniqueInput>
    disconnect?: Enumerable<citiesWhereUniqueInput>
    delete?: Enumerable<citiesWhereUniqueInput>
    update?: Enumerable<citiesUpdateWithWhereUniqueWithoutCountriesInput>
    updateMany?: Enumerable<citiesUpdateManyWithWhereWithoutCountriesInput>
    deleteMany?: Enumerable<citiesScalarWhereInput>
  }

  export type contacts_channelsCreateNestedManyWithoutPreferencesInput = {
    create?: XOR<Enumerable<contacts_channelsCreateWithoutPreferencesInput>, Enumerable<contacts_channelsUncheckedCreateWithoutPreferencesInput>>
    connectOrCreate?: Enumerable<contacts_channelsCreateOrConnectWithoutPreferencesInput>
    createMany?: contacts_channelsCreateManyPreferencesInputEnvelope
    connect?: Enumerable<contacts_channelsWhereUniqueInput>
  }

  export type contacts_channelsUncheckedCreateNestedManyWithoutPreferencesInput = {
    create?: XOR<Enumerable<contacts_channelsCreateWithoutPreferencesInput>, Enumerable<contacts_channelsUncheckedCreateWithoutPreferencesInput>>
    connectOrCreate?: Enumerable<contacts_channelsCreateOrConnectWithoutPreferencesInput>
    createMany?: contacts_channelsCreateManyPreferencesInputEnvelope
    connect?: Enumerable<contacts_channelsWhereUniqueInput>
  }

  export type contacts_channelsUpdateManyWithoutPreferencesInput = {
    create?: XOR<Enumerable<contacts_channelsCreateWithoutPreferencesInput>, Enumerable<contacts_channelsUncheckedCreateWithoutPreferencesInput>>
    connectOrCreate?: Enumerable<contacts_channelsCreateOrConnectWithoutPreferencesInput>
    upsert?: Enumerable<contacts_channelsUpsertWithWhereUniqueWithoutPreferencesInput>
    createMany?: contacts_channelsCreateManyPreferencesInputEnvelope
    connect?: Enumerable<contacts_channelsWhereUniqueInput>
    set?: Enumerable<contacts_channelsWhereUniqueInput>
    disconnect?: Enumerable<contacts_channelsWhereUniqueInput>
    delete?: Enumerable<contacts_channelsWhereUniqueInput>
    update?: Enumerable<contacts_channelsUpdateWithWhereUniqueWithoutPreferencesInput>
    updateMany?: Enumerable<contacts_channelsUpdateManyWithWhereWithoutPreferencesInput>
    deleteMany?: Enumerable<contacts_channelsScalarWhereInput>
  }

  export type contacts_channelsUncheckedUpdateManyWithoutPreferencesInput = {
    create?: XOR<Enumerable<contacts_channelsCreateWithoutPreferencesInput>, Enumerable<contacts_channelsUncheckedCreateWithoutPreferencesInput>>
    connectOrCreate?: Enumerable<contacts_channelsCreateOrConnectWithoutPreferencesInput>
    upsert?: Enumerable<contacts_channelsUpsertWithWhereUniqueWithoutPreferencesInput>
    createMany?: contacts_channelsCreateManyPreferencesInputEnvelope
    connect?: Enumerable<contacts_channelsWhereUniqueInput>
    set?: Enumerable<contacts_channelsWhereUniqueInput>
    disconnect?: Enumerable<contacts_channelsWhereUniqueInput>
    delete?: Enumerable<contacts_channelsWhereUniqueInput>
    update?: Enumerable<contacts_channelsUpdateWithWhereUniqueWithoutPreferencesInput>
    updateMany?: Enumerable<contacts_channelsUpdateManyWithWhereWithoutPreferencesInput>
    deleteMany?: Enumerable<contacts_channelsScalarWhereInput>
  }

  export type countriesCreateNestedManyWithoutRegionsInput = {
    create?: XOR<Enumerable<countriesCreateWithoutRegionsInput>, Enumerable<countriesUncheckedCreateWithoutRegionsInput>>
    connectOrCreate?: Enumerable<countriesCreateOrConnectWithoutRegionsInput>
    createMany?: countriesCreateManyRegionsInputEnvelope
    connect?: Enumerable<countriesWhereUniqueInput>
  }

  export type countriesUncheckedCreateNestedManyWithoutRegionsInput = {
    create?: XOR<Enumerable<countriesCreateWithoutRegionsInput>, Enumerable<countriesUncheckedCreateWithoutRegionsInput>>
    connectOrCreate?: Enumerable<countriesCreateOrConnectWithoutRegionsInput>
    createMany?: countriesCreateManyRegionsInputEnvelope
    connect?: Enumerable<countriesWhereUniqueInput>
  }

  export type countriesUpdateManyWithoutRegionsInput = {
    create?: XOR<Enumerable<countriesCreateWithoutRegionsInput>, Enumerable<countriesUncheckedCreateWithoutRegionsInput>>
    connectOrCreate?: Enumerable<countriesCreateOrConnectWithoutRegionsInput>
    upsert?: Enumerable<countriesUpsertWithWhereUniqueWithoutRegionsInput>
    createMany?: countriesCreateManyRegionsInputEnvelope
    connect?: Enumerable<countriesWhereUniqueInput>
    set?: Enumerable<countriesWhereUniqueInput>
    disconnect?: Enumerable<countriesWhereUniqueInput>
    delete?: Enumerable<countriesWhereUniqueInput>
    update?: Enumerable<countriesUpdateWithWhereUniqueWithoutRegionsInput>
    updateMany?: Enumerable<countriesUpdateManyWithWhereWithoutRegionsInput>
    deleteMany?: Enumerable<countriesScalarWhereInput>
  }

  export type countriesUncheckedUpdateManyWithoutRegionsInput = {
    create?: XOR<Enumerable<countriesCreateWithoutRegionsInput>, Enumerable<countriesUncheckedCreateWithoutRegionsInput>>
    connectOrCreate?: Enumerable<countriesCreateOrConnectWithoutRegionsInput>
    upsert?: Enumerable<countriesUpsertWithWhereUniqueWithoutRegionsInput>
    createMany?: countriesCreateManyRegionsInputEnvelope
    connect?: Enumerable<countriesWhereUniqueInput>
    set?: Enumerable<countriesWhereUniqueInput>
    disconnect?: Enumerable<countriesWhereUniqueInput>
    delete?: Enumerable<countriesWhereUniqueInput>
    update?: Enumerable<countriesUpdateWithWhereUniqueWithoutRegionsInput>
    updateMany?: Enumerable<countriesUpdateManyWithWhereWithoutRegionsInput>
    deleteMany?: Enumerable<countriesScalarWhereInput>
  }

  export type contactsCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<contactsCreateWithoutUsersInput>, Enumerable<contactsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<contactsCreateOrConnectWithoutUsersInput>
    createMany?: contactsCreateManyUsersInputEnvelope
    connect?: Enumerable<contactsWhereUniqueInput>
  }

  export type contactsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<contactsCreateWithoutUsersInput>, Enumerable<contactsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<contactsCreateOrConnectWithoutUsersInput>
    createMany?: contactsCreateManyUsersInputEnvelope
    connect?: Enumerable<contactsWhereUniqueInput>
  }

  export type contactsUpdateManyWithoutUsersInput = {
    create?: XOR<Enumerable<contactsCreateWithoutUsersInput>, Enumerable<contactsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<contactsCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<contactsUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: contactsCreateManyUsersInputEnvelope
    connect?: Enumerable<contactsWhereUniqueInput>
    set?: Enumerable<contactsWhereUniqueInput>
    disconnect?: Enumerable<contactsWhereUniqueInput>
    delete?: Enumerable<contactsWhereUniqueInput>
    update?: Enumerable<contactsUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<contactsUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<contactsScalarWhereInput>
  }

  export type contactsUncheckedUpdateManyWithoutUsersInput = {
    create?: XOR<Enumerable<contactsCreateWithoutUsersInput>, Enumerable<contactsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<contactsCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<contactsUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: contactsCreateManyUsersInputEnvelope
    connect?: Enumerable<contactsWhereUniqueInput>
    set?: Enumerable<contactsWhereUniqueInput>
    disconnect?: Enumerable<contactsWhereUniqueInput>
    delete?: Enumerable<contactsWhereUniqueInput>
    update?: Enumerable<contactsUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<contactsUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<contactsScalarWhereInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type contacts_channelsCreateWithoutChannelsInput = {
    acount: string
    contacts: contactsCreateNestedOneWithoutContacts_channelsInput
    preferences: preferencesCreateNestedOneWithoutContacts_channelsInput
  }

  export type contacts_channelsUncheckedCreateWithoutChannelsInput = {
    id?: number
    acount: string
    preferences_id: number
    contacts_id: number
  }

  export type contacts_channelsCreateOrConnectWithoutChannelsInput = {
    where: contacts_channelsWhereUniqueInput
    create: XOR<contacts_channelsCreateWithoutChannelsInput, contacts_channelsUncheckedCreateWithoutChannelsInput>
  }

  export type contacts_channelsCreateManyChannelsInputEnvelope = {
    data: Enumerable<contacts_channelsCreateManyChannelsInput>
    skipDuplicates?: boolean
  }

  export type contacts_channelsUpsertWithWhereUniqueWithoutChannelsInput = {
    where: contacts_channelsWhereUniqueInput
    update: XOR<contacts_channelsUpdateWithoutChannelsInput, contacts_channelsUncheckedUpdateWithoutChannelsInput>
    create: XOR<contacts_channelsCreateWithoutChannelsInput, contacts_channelsUncheckedCreateWithoutChannelsInput>
  }

  export type contacts_channelsUpdateWithWhereUniqueWithoutChannelsInput = {
    where: contacts_channelsWhereUniqueInput
    data: XOR<contacts_channelsUpdateWithoutChannelsInput, contacts_channelsUncheckedUpdateWithoutChannelsInput>
  }

  export type contacts_channelsUpdateManyWithWhereWithoutChannelsInput = {
    where: contacts_channelsScalarWhereInput
    data: XOR<contacts_channelsUpdateManyMutationInput, contacts_channelsUncheckedUpdateManyWithoutContacts_channelsInput>
  }

  export type contacts_channelsScalarWhereInput = {
    AND?: Enumerable<contacts_channelsScalarWhereInput>
    OR?: Enumerable<contacts_channelsScalarWhereInput>
    NOT?: Enumerable<contacts_channelsScalarWhereInput>
    id?: IntFilter | number
    acount?: StringFilter | string
    channels_id?: IntFilter | number
    preferences_id?: IntFilter | number
    contacts_id?: IntFilter | number
  }

  export type countriesCreateWithoutCitiesInput = {
    name: string
    isactive?: boolean | null
    regions: regionsCreateNestedOneWithoutCountriesInput
  }

  export type countriesUncheckedCreateWithoutCitiesInput = {
    id?: number
    name: string
    regions_id: number
    isactive?: boolean | null
  }

  export type countriesCreateOrConnectWithoutCitiesInput = {
    where: countriesWhereUniqueInput
    create: XOR<countriesCreateWithoutCitiesInput, countriesUncheckedCreateWithoutCitiesInput>
  }

  export type companiesCreateWithoutCitiesInput = {
    name: string
    address: string
    email: string
    phone: string
    isactive?: boolean | null
    contacts?: contactsCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutCitiesInput = {
    id?: number
    name: string
    address: string
    email: string
    phone: string
    isactive?: boolean | null
    contacts?: contactsUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutCitiesInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutCitiesInput, companiesUncheckedCreateWithoutCitiesInput>
  }

  export type companiesCreateManyCitiesInputEnvelope = {
    data: Enumerable<companiesCreateManyCitiesInput>
    skipDuplicates?: boolean
  }

  export type contactsCreateWithoutCitiesInput = {
    username: string
    lastname: string
    email: string
    job_tittle: string
    create_time?: Date | string | null
    address?: string | null
    interest?: number | null
    imgUrl?: string | null
    isactive?: boolean | null
    companies: companiesCreateNestedOneWithoutContactsInput
    users: usersCreateNestedOneWithoutContactsInput
    contacts_channels?: contacts_channelsCreateNestedManyWithoutContactsInput
  }

  export type contactsUncheckedCreateWithoutCitiesInput = {
    id?: number
    username: string
    lastname: string
    email: string
    job_tittle: string
    create_time?: Date | string | null
    address?: string | null
    interest?: number | null
    imgUrl?: string | null
    users_id: number
    companies_id: number
    isactive?: boolean | null
    contacts_channels?: contacts_channelsUncheckedCreateNestedManyWithoutContactsInput
  }

  export type contactsCreateOrConnectWithoutCitiesInput = {
    where: contactsWhereUniqueInput
    create: XOR<contactsCreateWithoutCitiesInput, contactsUncheckedCreateWithoutCitiesInput>
  }

  export type contactsCreateManyCitiesInputEnvelope = {
    data: Enumerable<contactsCreateManyCitiesInput>
    skipDuplicates?: boolean
  }

  export type countriesUpsertWithoutCitiesInput = {
    update: XOR<countriesUpdateWithoutCitiesInput, countriesUncheckedUpdateWithoutCitiesInput>
    create: XOR<countriesCreateWithoutCitiesInput, countriesUncheckedCreateWithoutCitiesInput>
  }

  export type countriesUpdateWithoutCitiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    regions?: regionsUpdateOneRequiredWithoutCountriesInput
  }

  export type countriesUncheckedUpdateWithoutCitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    regions_id?: IntFieldUpdateOperationsInput | number
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type companiesUpsertWithWhereUniqueWithoutCitiesInput = {
    where: companiesWhereUniqueInput
    update: XOR<companiesUpdateWithoutCitiesInput, companiesUncheckedUpdateWithoutCitiesInput>
    create: XOR<companiesCreateWithoutCitiesInput, companiesUncheckedCreateWithoutCitiesInput>
  }

  export type companiesUpdateWithWhereUniqueWithoutCitiesInput = {
    where: companiesWhereUniqueInput
    data: XOR<companiesUpdateWithoutCitiesInput, companiesUncheckedUpdateWithoutCitiesInput>
  }

  export type companiesUpdateManyWithWhereWithoutCitiesInput = {
    where: companiesScalarWhereInput
    data: XOR<companiesUpdateManyMutationInput, companiesUncheckedUpdateManyWithoutCompaniesInput>
  }

  export type companiesScalarWhereInput = {
    AND?: Enumerable<companiesScalarWhereInput>
    OR?: Enumerable<companiesScalarWhereInput>
    NOT?: Enumerable<companiesScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    address?: StringFilter | string
    email?: StringFilter | string
    phone?: StringFilter | string
    cities_id?: IntFilter | number
    isactive?: BoolNullableFilter | boolean | null
  }

  export type contactsUpsertWithWhereUniqueWithoutCitiesInput = {
    where: contactsWhereUniqueInput
    update: XOR<contactsUpdateWithoutCitiesInput, contactsUncheckedUpdateWithoutCitiesInput>
    create: XOR<contactsCreateWithoutCitiesInput, contactsUncheckedCreateWithoutCitiesInput>
  }

  export type contactsUpdateWithWhereUniqueWithoutCitiesInput = {
    where: contactsWhereUniqueInput
    data: XOR<contactsUpdateWithoutCitiesInput, contactsUncheckedUpdateWithoutCitiesInput>
  }

  export type contactsUpdateManyWithWhereWithoutCitiesInput = {
    where: contactsScalarWhereInput
    data: XOR<contactsUpdateManyMutationInput, contactsUncheckedUpdateManyWithoutContactsInput>
  }

  export type contactsScalarWhereInput = {
    AND?: Enumerable<contactsScalarWhereInput>
    OR?: Enumerable<contactsScalarWhereInput>
    NOT?: Enumerable<contactsScalarWhereInput>
    id?: IntFilter | number
    username?: StringFilter | string
    lastname?: StringFilter | string
    email?: StringFilter | string
    job_tittle?: StringFilter | string
    create_time?: DateTimeNullableFilter | Date | string | null
    address?: StringNullableFilter | string | null
    interest?: IntNullableFilter | number | null
    imgUrl?: StringNullableFilter | string | null
    users_id?: IntFilter | number
    companies_id?: IntFilter | number
    cities_id?: IntFilter | number
    isactive?: BoolNullableFilter | boolean | null
  }

  export type citiesCreateWithoutCompaniesInput = {
    name: string
    isactive?: boolean | null
    countries: countriesCreateNestedOneWithoutCitiesInput
    contacts?: contactsCreateNestedManyWithoutCitiesInput
  }

  export type citiesUncheckedCreateWithoutCompaniesInput = {
    id?: number
    name: string
    countries_id: number
    isactive?: boolean | null
    contacts?: contactsUncheckedCreateNestedManyWithoutCitiesInput
  }

  export type citiesCreateOrConnectWithoutCompaniesInput = {
    where: citiesWhereUniqueInput
    create: XOR<citiesCreateWithoutCompaniesInput, citiesUncheckedCreateWithoutCompaniesInput>
  }

  export type contactsCreateWithoutCompaniesInput = {
    username: string
    lastname: string
    email: string
    job_tittle: string
    create_time?: Date | string | null
    address?: string | null
    interest?: number | null
    imgUrl?: string | null
    isactive?: boolean | null
    cities: citiesCreateNestedOneWithoutContactsInput
    users: usersCreateNestedOneWithoutContactsInput
    contacts_channels?: contacts_channelsCreateNestedManyWithoutContactsInput
  }

  export type contactsUncheckedCreateWithoutCompaniesInput = {
    id?: number
    username: string
    lastname: string
    email: string
    job_tittle: string
    create_time?: Date | string | null
    address?: string | null
    interest?: number | null
    imgUrl?: string | null
    users_id: number
    cities_id: number
    isactive?: boolean | null
    contacts_channels?: contacts_channelsUncheckedCreateNestedManyWithoutContactsInput
  }

  export type contactsCreateOrConnectWithoutCompaniesInput = {
    where: contactsWhereUniqueInput
    create: XOR<contactsCreateWithoutCompaniesInput, contactsUncheckedCreateWithoutCompaniesInput>
  }

  export type contactsCreateManyCompaniesInputEnvelope = {
    data: Enumerable<contactsCreateManyCompaniesInput>
    skipDuplicates?: boolean
  }

  export type citiesUpsertWithoutCompaniesInput = {
    update: XOR<citiesUpdateWithoutCompaniesInput, citiesUncheckedUpdateWithoutCompaniesInput>
    create: XOR<citiesCreateWithoutCompaniesInput, citiesUncheckedCreateWithoutCompaniesInput>
  }

  export type citiesUpdateWithoutCompaniesInput = {
    name?: StringFieldUpdateOperationsInput | string
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    countries?: countriesUpdateOneRequiredWithoutCitiesInput
    contacts?: contactsUpdateManyWithoutCitiesInput
  }

  export type citiesUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    countries_id?: IntFieldUpdateOperationsInput | number
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contacts?: contactsUncheckedUpdateManyWithoutCitiesInput
  }

  export type contactsUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: contactsWhereUniqueInput
    update: XOR<contactsUpdateWithoutCompaniesInput, contactsUncheckedUpdateWithoutCompaniesInput>
    create: XOR<contactsCreateWithoutCompaniesInput, contactsUncheckedCreateWithoutCompaniesInput>
  }

  export type contactsUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: contactsWhereUniqueInput
    data: XOR<contactsUpdateWithoutCompaniesInput, contactsUncheckedUpdateWithoutCompaniesInput>
  }

  export type contactsUpdateManyWithWhereWithoutCompaniesInput = {
    where: contactsScalarWhereInput
    data: XOR<contactsUpdateManyMutationInput, contactsUncheckedUpdateManyWithoutContactsInput>
  }

  export type citiesCreateWithoutContactsInput = {
    name: string
    isactive?: boolean | null
    countries: countriesCreateNestedOneWithoutCitiesInput
    companies?: companiesCreateNestedManyWithoutCitiesInput
  }

  export type citiesUncheckedCreateWithoutContactsInput = {
    id?: number
    name: string
    countries_id: number
    isactive?: boolean | null
    companies?: companiesUncheckedCreateNestedManyWithoutCitiesInput
  }

  export type citiesCreateOrConnectWithoutContactsInput = {
    where: citiesWhereUniqueInput
    create: XOR<citiesCreateWithoutContactsInput, citiesUncheckedCreateWithoutContactsInput>
  }

  export type companiesCreateWithoutContactsInput = {
    name: string
    address: string
    email: string
    phone: string
    isactive?: boolean | null
    cities: citiesCreateNestedOneWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutContactsInput = {
    id?: number
    name: string
    address: string
    email: string
    phone: string
    cities_id: number
    isactive?: boolean | null
  }

  export type companiesCreateOrConnectWithoutContactsInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutContactsInput, companiesUncheckedCreateWithoutContactsInput>
  }

  export type usersCreateWithoutContactsInput = {
    username: string
    lastname: string
    email: string
    password: string
    create_time?: Date | string | null
    isadmin?: boolean | null
    isactive?: boolean | null
  }

  export type usersUncheckedCreateWithoutContactsInput = {
    id?: number
    username: string
    lastname: string
    email: string
    password: string
    create_time?: Date | string | null
    isadmin?: boolean | null
    isactive?: boolean | null
  }

  export type usersCreateOrConnectWithoutContactsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutContactsInput, usersUncheckedCreateWithoutContactsInput>
  }

  export type contacts_channelsCreateWithoutContactsInput = {
    acount: string
    channels: channelsCreateNestedOneWithoutContacts_channelsInput
    preferences: preferencesCreateNestedOneWithoutContacts_channelsInput
  }

  export type contacts_channelsUncheckedCreateWithoutContactsInput = {
    id?: number
    acount: string
    channels_id: number
    preferences_id: number
  }

  export type contacts_channelsCreateOrConnectWithoutContactsInput = {
    where: contacts_channelsWhereUniqueInput
    create: XOR<contacts_channelsCreateWithoutContactsInput, contacts_channelsUncheckedCreateWithoutContactsInput>
  }

  export type contacts_channelsCreateManyContactsInputEnvelope = {
    data: Enumerable<contacts_channelsCreateManyContactsInput>
    skipDuplicates?: boolean
  }

  export type citiesUpsertWithoutContactsInput = {
    update: XOR<citiesUpdateWithoutContactsInput, citiesUncheckedUpdateWithoutContactsInput>
    create: XOR<citiesCreateWithoutContactsInput, citiesUncheckedCreateWithoutContactsInput>
  }

  export type citiesUpdateWithoutContactsInput = {
    name?: StringFieldUpdateOperationsInput | string
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    countries?: countriesUpdateOneRequiredWithoutCitiesInput
    companies?: companiesUpdateManyWithoutCitiesInput
  }

  export type citiesUncheckedUpdateWithoutContactsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    countries_id?: IntFieldUpdateOperationsInput | number
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    companies?: companiesUncheckedUpdateManyWithoutCitiesInput
  }

  export type companiesUpsertWithoutContactsInput = {
    update: XOR<companiesUpdateWithoutContactsInput, companiesUncheckedUpdateWithoutContactsInput>
    create: XOR<companiesCreateWithoutContactsInput, companiesUncheckedCreateWithoutContactsInput>
  }

  export type companiesUpdateWithoutContactsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cities?: citiesUpdateOneRequiredWithoutCompaniesInput
  }

  export type companiesUncheckedUpdateWithoutContactsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    cities_id?: IntFieldUpdateOperationsInput | number
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type usersUpsertWithoutContactsInput = {
    update: XOR<usersUpdateWithoutContactsInput, usersUncheckedUpdateWithoutContactsInput>
    create: XOR<usersCreateWithoutContactsInput, usersUncheckedCreateWithoutContactsInput>
  }

  export type usersUpdateWithoutContactsInput = {
    username?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    create_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isadmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type usersUncheckedUpdateWithoutContactsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    create_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isadmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type contacts_channelsUpsertWithWhereUniqueWithoutContactsInput = {
    where: contacts_channelsWhereUniqueInput
    update: XOR<contacts_channelsUpdateWithoutContactsInput, contacts_channelsUncheckedUpdateWithoutContactsInput>
    create: XOR<contacts_channelsCreateWithoutContactsInput, contacts_channelsUncheckedCreateWithoutContactsInput>
  }

  export type contacts_channelsUpdateWithWhereUniqueWithoutContactsInput = {
    where: contacts_channelsWhereUniqueInput
    data: XOR<contacts_channelsUpdateWithoutContactsInput, contacts_channelsUncheckedUpdateWithoutContactsInput>
  }

  export type contacts_channelsUpdateManyWithWhereWithoutContactsInput = {
    where: contacts_channelsScalarWhereInput
    data: XOR<contacts_channelsUpdateManyMutationInput, contacts_channelsUncheckedUpdateManyWithoutContacts_channelsInput>
  }

  export type channelsCreateWithoutContacts_channelsInput = {
    name: string
  }

  export type channelsUncheckedCreateWithoutContacts_channelsInput = {
    id?: number
    name: string
  }

  export type channelsCreateOrConnectWithoutContacts_channelsInput = {
    where: channelsWhereUniqueInput
    create: XOR<channelsCreateWithoutContacts_channelsInput, channelsUncheckedCreateWithoutContacts_channelsInput>
  }

  export type contactsCreateWithoutContacts_channelsInput = {
    username: string
    lastname: string
    email: string
    job_tittle: string
    create_time?: Date | string | null
    address?: string | null
    interest?: number | null
    imgUrl?: string | null
    isactive?: boolean | null
    cities: citiesCreateNestedOneWithoutContactsInput
    companies: companiesCreateNestedOneWithoutContactsInput
    users: usersCreateNestedOneWithoutContactsInput
  }

  export type contactsUncheckedCreateWithoutContacts_channelsInput = {
    id?: number
    username: string
    lastname: string
    email: string
    job_tittle: string
    create_time?: Date | string | null
    address?: string | null
    interest?: number | null
    imgUrl?: string | null
    users_id: number
    companies_id: number
    cities_id: number
    isactive?: boolean | null
  }

  export type contactsCreateOrConnectWithoutContacts_channelsInput = {
    where: contactsWhereUniqueInput
    create: XOR<contactsCreateWithoutContacts_channelsInput, contactsUncheckedCreateWithoutContacts_channelsInput>
  }

  export type preferencesCreateWithoutContacts_channelsInput = {
    name: string
  }

  export type preferencesUncheckedCreateWithoutContacts_channelsInput = {
    id?: number
    name: string
  }

  export type preferencesCreateOrConnectWithoutContacts_channelsInput = {
    where: preferencesWhereUniqueInput
    create: XOR<preferencesCreateWithoutContacts_channelsInput, preferencesUncheckedCreateWithoutContacts_channelsInput>
  }

  export type channelsUpsertWithoutContacts_channelsInput = {
    update: XOR<channelsUpdateWithoutContacts_channelsInput, channelsUncheckedUpdateWithoutContacts_channelsInput>
    create: XOR<channelsCreateWithoutContacts_channelsInput, channelsUncheckedCreateWithoutContacts_channelsInput>
  }

  export type channelsUpdateWithoutContacts_channelsInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type channelsUncheckedUpdateWithoutContacts_channelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type contactsUpsertWithoutContacts_channelsInput = {
    update: XOR<contactsUpdateWithoutContacts_channelsInput, contactsUncheckedUpdateWithoutContacts_channelsInput>
    create: XOR<contactsCreateWithoutContacts_channelsInput, contactsUncheckedCreateWithoutContacts_channelsInput>
  }

  export type contactsUpdateWithoutContacts_channelsInput = {
    username?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    job_tittle?: StringFieldUpdateOperationsInput | string
    create_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    interest?: NullableIntFieldUpdateOperationsInput | number | null
    imgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cities?: citiesUpdateOneRequiredWithoutContactsInput
    companies?: companiesUpdateOneRequiredWithoutContactsInput
    users?: usersUpdateOneRequiredWithoutContactsInput
  }

  export type contactsUncheckedUpdateWithoutContacts_channelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    job_tittle?: StringFieldUpdateOperationsInput | string
    create_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    interest?: NullableIntFieldUpdateOperationsInput | number | null
    imgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    users_id?: IntFieldUpdateOperationsInput | number
    companies_id?: IntFieldUpdateOperationsInput | number
    cities_id?: IntFieldUpdateOperationsInput | number
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type preferencesUpsertWithoutContacts_channelsInput = {
    update: XOR<preferencesUpdateWithoutContacts_channelsInput, preferencesUncheckedUpdateWithoutContacts_channelsInput>
    create: XOR<preferencesCreateWithoutContacts_channelsInput, preferencesUncheckedCreateWithoutContacts_channelsInput>
  }

  export type preferencesUpdateWithoutContacts_channelsInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type preferencesUncheckedUpdateWithoutContacts_channelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type regionsCreateWithoutCountriesInput = {
    name: string
    isactive?: boolean | null
  }

  export type regionsUncheckedCreateWithoutCountriesInput = {
    id?: number
    name: string
    isactive?: boolean | null
  }

  export type regionsCreateOrConnectWithoutCountriesInput = {
    where: regionsWhereUniqueInput
    create: XOR<regionsCreateWithoutCountriesInput, regionsUncheckedCreateWithoutCountriesInput>
  }

  export type citiesCreateWithoutCountriesInput = {
    name: string
    isactive?: boolean | null
    companies?: companiesCreateNestedManyWithoutCitiesInput
    contacts?: contactsCreateNestedManyWithoutCitiesInput
  }

  export type citiesUncheckedCreateWithoutCountriesInput = {
    id?: number
    name: string
    isactive?: boolean | null
    companies?: companiesUncheckedCreateNestedManyWithoutCitiesInput
    contacts?: contactsUncheckedCreateNestedManyWithoutCitiesInput
  }

  export type citiesCreateOrConnectWithoutCountriesInput = {
    where: citiesWhereUniqueInput
    create: XOR<citiesCreateWithoutCountriesInput, citiesUncheckedCreateWithoutCountriesInput>
  }

  export type citiesCreateManyCountriesInputEnvelope = {
    data: Enumerable<citiesCreateManyCountriesInput>
    skipDuplicates?: boolean
  }

  export type regionsUpsertWithoutCountriesInput = {
    update: XOR<regionsUpdateWithoutCountriesInput, regionsUncheckedUpdateWithoutCountriesInput>
    create: XOR<regionsCreateWithoutCountriesInput, regionsUncheckedCreateWithoutCountriesInput>
  }

  export type regionsUpdateWithoutCountriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type regionsUncheckedUpdateWithoutCountriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type citiesUpsertWithWhereUniqueWithoutCountriesInput = {
    where: citiesWhereUniqueInput
    update: XOR<citiesUpdateWithoutCountriesInput, citiesUncheckedUpdateWithoutCountriesInput>
    create: XOR<citiesCreateWithoutCountriesInput, citiesUncheckedCreateWithoutCountriesInput>
  }

  export type citiesUpdateWithWhereUniqueWithoutCountriesInput = {
    where: citiesWhereUniqueInput
    data: XOR<citiesUpdateWithoutCountriesInput, citiesUncheckedUpdateWithoutCountriesInput>
  }

  export type citiesUpdateManyWithWhereWithoutCountriesInput = {
    where: citiesScalarWhereInput
    data: XOR<citiesUpdateManyMutationInput, citiesUncheckedUpdateManyWithoutCitiesInput>
  }

  export type citiesScalarWhereInput = {
    AND?: Enumerable<citiesScalarWhereInput>
    OR?: Enumerable<citiesScalarWhereInput>
    NOT?: Enumerable<citiesScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    countries_id?: IntFilter | number
    isactive?: BoolNullableFilter | boolean | null
  }

  export type contacts_channelsCreateWithoutPreferencesInput = {
    acount: string
    channels: channelsCreateNestedOneWithoutContacts_channelsInput
    contacts: contactsCreateNestedOneWithoutContacts_channelsInput
  }

  export type contacts_channelsUncheckedCreateWithoutPreferencesInput = {
    id?: number
    acount: string
    channels_id: number
    contacts_id: number
  }

  export type contacts_channelsCreateOrConnectWithoutPreferencesInput = {
    where: contacts_channelsWhereUniqueInput
    create: XOR<contacts_channelsCreateWithoutPreferencesInput, contacts_channelsUncheckedCreateWithoutPreferencesInput>
  }

  export type contacts_channelsCreateManyPreferencesInputEnvelope = {
    data: Enumerable<contacts_channelsCreateManyPreferencesInput>
    skipDuplicates?: boolean
  }

  export type contacts_channelsUpsertWithWhereUniqueWithoutPreferencesInput = {
    where: contacts_channelsWhereUniqueInput
    update: XOR<contacts_channelsUpdateWithoutPreferencesInput, contacts_channelsUncheckedUpdateWithoutPreferencesInput>
    create: XOR<contacts_channelsCreateWithoutPreferencesInput, contacts_channelsUncheckedCreateWithoutPreferencesInput>
  }

  export type contacts_channelsUpdateWithWhereUniqueWithoutPreferencesInput = {
    where: contacts_channelsWhereUniqueInput
    data: XOR<contacts_channelsUpdateWithoutPreferencesInput, contacts_channelsUncheckedUpdateWithoutPreferencesInput>
  }

  export type contacts_channelsUpdateManyWithWhereWithoutPreferencesInput = {
    where: contacts_channelsScalarWhereInput
    data: XOR<contacts_channelsUpdateManyMutationInput, contacts_channelsUncheckedUpdateManyWithoutContacts_channelsInput>
  }

  export type countriesCreateWithoutRegionsInput = {
    name: string
    isactive?: boolean | null
    cities?: citiesCreateNestedManyWithoutCountriesInput
  }

  export type countriesUncheckedCreateWithoutRegionsInput = {
    id?: number
    name: string
    isactive?: boolean | null
    cities?: citiesUncheckedCreateNestedManyWithoutCountriesInput
  }

  export type countriesCreateOrConnectWithoutRegionsInput = {
    where: countriesWhereUniqueInput
    create: XOR<countriesCreateWithoutRegionsInput, countriesUncheckedCreateWithoutRegionsInput>
  }

  export type countriesCreateManyRegionsInputEnvelope = {
    data: Enumerable<countriesCreateManyRegionsInput>
    skipDuplicates?: boolean
  }

  export type countriesUpsertWithWhereUniqueWithoutRegionsInput = {
    where: countriesWhereUniqueInput
    update: XOR<countriesUpdateWithoutRegionsInput, countriesUncheckedUpdateWithoutRegionsInput>
    create: XOR<countriesCreateWithoutRegionsInput, countriesUncheckedCreateWithoutRegionsInput>
  }

  export type countriesUpdateWithWhereUniqueWithoutRegionsInput = {
    where: countriesWhereUniqueInput
    data: XOR<countriesUpdateWithoutRegionsInput, countriesUncheckedUpdateWithoutRegionsInput>
  }

  export type countriesUpdateManyWithWhereWithoutRegionsInput = {
    where: countriesScalarWhereInput
    data: XOR<countriesUpdateManyMutationInput, countriesUncheckedUpdateManyWithoutCountriesInput>
  }

  export type countriesScalarWhereInput = {
    AND?: Enumerable<countriesScalarWhereInput>
    OR?: Enumerable<countriesScalarWhereInput>
    NOT?: Enumerable<countriesScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    regions_id?: IntFilter | number
    isactive?: BoolNullableFilter | boolean | null
  }

  export type contactsCreateWithoutUsersInput = {
    username: string
    lastname: string
    email: string
    job_tittle: string
    create_time?: Date | string | null
    address?: string | null
    interest?: number | null
    imgUrl?: string | null
    isactive?: boolean | null
    cities: citiesCreateNestedOneWithoutContactsInput
    companies: companiesCreateNestedOneWithoutContactsInput
    contacts_channels?: contacts_channelsCreateNestedManyWithoutContactsInput
  }

  export type contactsUncheckedCreateWithoutUsersInput = {
    id?: number
    username: string
    lastname: string
    email: string
    job_tittle: string
    create_time?: Date | string | null
    address?: string | null
    interest?: number | null
    imgUrl?: string | null
    companies_id: number
    cities_id: number
    isactive?: boolean | null
    contacts_channels?: contacts_channelsUncheckedCreateNestedManyWithoutContactsInput
  }

  export type contactsCreateOrConnectWithoutUsersInput = {
    where: contactsWhereUniqueInput
    create: XOR<contactsCreateWithoutUsersInput, contactsUncheckedCreateWithoutUsersInput>
  }

  export type contactsCreateManyUsersInputEnvelope = {
    data: Enumerable<contactsCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type contactsUpsertWithWhereUniqueWithoutUsersInput = {
    where: contactsWhereUniqueInput
    update: XOR<contactsUpdateWithoutUsersInput, contactsUncheckedUpdateWithoutUsersInput>
    create: XOR<contactsCreateWithoutUsersInput, contactsUncheckedCreateWithoutUsersInput>
  }

  export type contactsUpdateWithWhereUniqueWithoutUsersInput = {
    where: contactsWhereUniqueInput
    data: XOR<contactsUpdateWithoutUsersInput, contactsUncheckedUpdateWithoutUsersInput>
  }

  export type contactsUpdateManyWithWhereWithoutUsersInput = {
    where: contactsScalarWhereInput
    data: XOR<contactsUpdateManyMutationInput, contactsUncheckedUpdateManyWithoutContactsInput>
  }

  export type contacts_channelsCreateManyChannelsInput = {
    id?: number
    acount: string
    preferences_id: number
    contacts_id: number
  }

  export type contacts_channelsUpdateWithoutChannelsInput = {
    acount?: StringFieldUpdateOperationsInput | string
    contacts?: contactsUpdateOneRequiredWithoutContacts_channelsInput
    preferences?: preferencesUpdateOneRequiredWithoutContacts_channelsInput
  }

  export type contacts_channelsUncheckedUpdateWithoutChannelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    acount?: StringFieldUpdateOperationsInput | string
    preferences_id?: IntFieldUpdateOperationsInput | number
    contacts_id?: IntFieldUpdateOperationsInput | number
  }

  export type contacts_channelsUncheckedUpdateManyWithoutContacts_channelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    acount?: StringFieldUpdateOperationsInput | string
    preferences_id?: IntFieldUpdateOperationsInput | number
    contacts_id?: IntFieldUpdateOperationsInput | number
  }

  export type companiesCreateManyCitiesInput = {
    id?: number
    name: string
    address: string
    email: string
    phone: string
    isactive?: boolean | null
  }

  export type contactsCreateManyCitiesInput = {
    id?: number
    username: string
    lastname: string
    email: string
    job_tittle: string
    create_time?: Date | string | null
    address?: string | null
    interest?: number | null
    imgUrl?: string | null
    users_id: number
    companies_id: number
    isactive?: boolean | null
  }

  export type companiesUpdateWithoutCitiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contacts?: contactsUpdateManyWithoutCompaniesInput
  }

  export type companiesUncheckedUpdateWithoutCitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contacts?: contactsUncheckedUpdateManyWithoutCompaniesInput
  }

  export type companiesUncheckedUpdateManyWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type contactsUpdateWithoutCitiesInput = {
    username?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    job_tittle?: StringFieldUpdateOperationsInput | string
    create_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    interest?: NullableIntFieldUpdateOperationsInput | number | null
    imgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    companies?: companiesUpdateOneRequiredWithoutContactsInput
    users?: usersUpdateOneRequiredWithoutContactsInput
    contacts_channels?: contacts_channelsUpdateManyWithoutContactsInput
  }

  export type contactsUncheckedUpdateWithoutCitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    job_tittle?: StringFieldUpdateOperationsInput | string
    create_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    interest?: NullableIntFieldUpdateOperationsInput | number | null
    imgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    users_id?: IntFieldUpdateOperationsInput | number
    companies_id?: IntFieldUpdateOperationsInput | number
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contacts_channels?: contacts_channelsUncheckedUpdateManyWithoutContactsInput
  }

  export type contactsUncheckedUpdateManyWithoutContactsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    job_tittle?: StringFieldUpdateOperationsInput | string
    create_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    interest?: NullableIntFieldUpdateOperationsInput | number | null
    imgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    users_id?: IntFieldUpdateOperationsInput | number
    companies_id?: IntFieldUpdateOperationsInput | number
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type contactsCreateManyCompaniesInput = {
    id?: number
    username: string
    lastname: string
    email: string
    job_tittle: string
    create_time?: Date | string | null
    address?: string | null
    interest?: number | null
    imgUrl?: string | null
    users_id: number
    cities_id: number
    isactive?: boolean | null
  }

  export type contactsUpdateWithoutCompaniesInput = {
    username?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    job_tittle?: StringFieldUpdateOperationsInput | string
    create_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    interest?: NullableIntFieldUpdateOperationsInput | number | null
    imgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cities?: citiesUpdateOneRequiredWithoutContactsInput
    users?: usersUpdateOneRequiredWithoutContactsInput
    contacts_channels?: contacts_channelsUpdateManyWithoutContactsInput
  }

  export type contactsUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    job_tittle?: StringFieldUpdateOperationsInput | string
    create_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    interest?: NullableIntFieldUpdateOperationsInput | number | null
    imgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    users_id?: IntFieldUpdateOperationsInput | number
    cities_id?: IntFieldUpdateOperationsInput | number
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contacts_channels?: contacts_channelsUncheckedUpdateManyWithoutContactsInput
  }

  export type contacts_channelsCreateManyContactsInput = {
    id?: number
    acount: string
    channels_id: number
    preferences_id: number
  }

  export type contacts_channelsUpdateWithoutContactsInput = {
    acount?: StringFieldUpdateOperationsInput | string
    channels?: channelsUpdateOneRequiredWithoutContacts_channelsInput
    preferences?: preferencesUpdateOneRequiredWithoutContacts_channelsInput
  }

  export type contacts_channelsUncheckedUpdateWithoutContactsInput = {
    id?: IntFieldUpdateOperationsInput | number
    acount?: StringFieldUpdateOperationsInput | string
    channels_id?: IntFieldUpdateOperationsInput | number
    preferences_id?: IntFieldUpdateOperationsInput | number
  }

  export type citiesCreateManyCountriesInput = {
    id?: number
    name: string
    isactive?: boolean | null
  }

  export type citiesUpdateWithoutCountriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    companies?: companiesUpdateManyWithoutCitiesInput
    contacts?: contactsUpdateManyWithoutCitiesInput
  }

  export type citiesUncheckedUpdateWithoutCountriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    companies?: companiesUncheckedUpdateManyWithoutCitiesInput
    contacts?: contactsUncheckedUpdateManyWithoutCitiesInput
  }

  export type citiesUncheckedUpdateManyWithoutCitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type contacts_channelsCreateManyPreferencesInput = {
    id?: number
    acount: string
    channels_id: number
    contacts_id: number
  }

  export type contacts_channelsUpdateWithoutPreferencesInput = {
    acount?: StringFieldUpdateOperationsInput | string
    channels?: channelsUpdateOneRequiredWithoutContacts_channelsInput
    contacts?: contactsUpdateOneRequiredWithoutContacts_channelsInput
  }

  export type contacts_channelsUncheckedUpdateWithoutPreferencesInput = {
    id?: IntFieldUpdateOperationsInput | number
    acount?: StringFieldUpdateOperationsInput | string
    channels_id?: IntFieldUpdateOperationsInput | number
    contacts_id?: IntFieldUpdateOperationsInput | number
  }

  export type countriesCreateManyRegionsInput = {
    id?: number
    name: string
    isactive?: boolean | null
  }

  export type countriesUpdateWithoutRegionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cities?: citiesUpdateManyWithoutCountriesInput
  }

  export type countriesUncheckedUpdateWithoutRegionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cities?: citiesUncheckedUpdateManyWithoutCountriesInput
  }

  export type countriesUncheckedUpdateManyWithoutCountriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type contactsCreateManyUsersInput = {
    id?: number
    username: string
    lastname: string
    email: string
    job_tittle: string
    create_time?: Date | string | null
    address?: string | null
    interest?: number | null
    imgUrl?: string | null
    companies_id: number
    cities_id: number
    isactive?: boolean | null
  }

  export type contactsUpdateWithoutUsersInput = {
    username?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    job_tittle?: StringFieldUpdateOperationsInput | string
    create_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    interest?: NullableIntFieldUpdateOperationsInput | number | null
    imgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cities?: citiesUpdateOneRequiredWithoutContactsInput
    companies?: companiesUpdateOneRequiredWithoutContactsInput
    contacts_channels?: contacts_channelsUpdateManyWithoutContactsInput
  }

  export type contactsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    job_tittle?: StringFieldUpdateOperationsInput | string
    create_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    interest?: NullableIntFieldUpdateOperationsInput | number | null
    imgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    companies_id?: IntFieldUpdateOperationsInput | number
    cities_id?: IntFieldUpdateOperationsInput | number
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contacts_channels?: contacts_channelsUncheckedUpdateManyWithoutContactsInput
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}